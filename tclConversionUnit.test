## tclConversionUnit.test# usage is tclsh tclConversionUnit.test -loadfile <configfileName> -outfile <resultsfilename>
set TEST_HOME [file normalize [file dirname [info script]]]
package require tcltest 2.2
package require otc
namespace import ::tcltest::*

eval ::tcltest::configure $argv
set CONTINUE "true"
loadTestedCommands
source $::TEST_HOME/tclConversionTestUtilities.tcl
set arrayInputOutputFile "$TEST_HOME/testdata/Array_Input_output.txt"

test tcl_unit_getConnectionSetup_1.1 {sets up model connection info to determine where to get data} {
    -setup {}
    -body {
        global modelDef
        setInitialArrays
        catch {getConnectionSetup modelDef $modelInputParam $MODEL_FILES_DIRECTORY} err
        if {${getConnectionSetup_1.1_names} == "negative"} {
            if {[regexp ${getConnectionSetup_1.1_result} $err]} {
                set err "{} {} {}"
            }
        } else {
            set err [diffArray2 ${getConnectionSetup_1.1_names} [array get modelDef] ${getConnectionSetup_1.1_result}]
            if {$err != "{} {} {}"} {
                append err should be:\n ${getConnectionSetup_1.1_result} \nis:\n [array get modelDef]
            }
        }
        return $err
    }

    -result {  {} {} {}  }
    -cleanup {dropAll dbCompare}
}
test tcl_unit_getConnectionSetup_1.2 {sets up target connection info to determine where to get data} {
    -setup {}
    -body {
        global testArray
        if {${getConnectionSetup_1.2_names} == "negative"} {
            catch {getConnectionSetup targetDef $targetConnection $MODEL_FILES_DIRECTORY} err
            if {[regexp ${getConnectionSetup_1.2_result} $err]} {
                set err "{} {} {}"
            }
        } else {
            # If schema not present in the schema List get it from schema pool
            catch {getConnectionSetup targetDef $targetConnection $MODEL_FILES_DIRECTORY} err
            set err [diffArray2 ${getConnectionSetup_1.2_names} [array get targetDef] ${getConnectionSetup_1.2_result}]
            if {$err != "{} {} {}"} {
            append err \n ${getConnectionSetup_1.2_result} \n [array get targetDef]
            }
        }
        return $err
    }

    -result { {} {} {} }
    -cleanup {dropAll dbCompare}
}

test tcl_unit_getMetaDataSource {sets up model and target metadata sources} {
    -setup {}
    -body {
        set result ""
        setInitialArrays
        array set modelDef [test_getConnectionSetup modelDef $modelInputParam $MODEL_FILES_DIRECTORY]
        array set targetDef [test_getConnectionSetup targetDef $targetConnection $MODEL_FILES_DIRECTORY]
         if [catch {getMetaDataSource modelDef targetDef} err] {
            return $err
        }
        ;# need to provide expected results, and compare actual results.
        if {${getMetaDataSource_result_1} != [getInfo dbCompare.modelDef.metaSource]} {
            lappend result [list EXPECTED: ${getMetaDataSource_result_1} RETURNED: [getInfo dbCompare.modelDef.metaSource]]
        }
        if {[regexp ${getMetaDataSource_result_2}  [getInfo dbCompare.modelDef.metaSourceLocation]] != 1} {
            lappend result [list EXPECTED: ${getMetaDataSource_result_2} RETURNED: [getInfo dbCompare.modelDef.metaSourceLocation]]
        }
        if {${getMetaDataSource_result_3} != [getInfo dbCompare.targetDef.metaSource]} {
            lappend result [list EXPECTED: ${getMetaDataSource_result_3} RETURNED: [getInfo dbCompare.targetDef.metaSource]]
        }
        if {[regexp ${getMetaDataSource_result_4} [getInfo dbCompare.targetDef.metaSourceLocation]] != 1} {
            lappend result [list EXPECTED: ${getMetaDataSource_result_4} RETURNED: [getInfo dbCompare.targetDef.metaSourceLocation]]
        }
        if {[set diff [diffArray2 ${getMetaDataSource_result_7} [array get modelDef] ${getMetaDataSource_result_5}]] != "{} {} {}"} {
            lappend result [list DIFFERENCE: $diff]
        }
        if {[set diff [diffArray2 ${getMetaDataSource_result_7} [array get targetDef] ${getMetaDataSource_result_6}]] != "{} {} {}"} {
            lappend result [list DIFFERENCE: $diff]
        }
        return $result
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
#DVT:629341
test tcl_unit_getDisplayConnection {Unit test for proc getDisplayConnection} {
    -setup {}
    -body {
        # If schema not present in the schema List get it from schema pool
    #TODO:
        set result [getDisplayConnection $targetConnection]
        set DisplayConnection [lindex [split $targetConnection /] 0]@[lindex [split $targetConnection @] 1]
        if {$result == $DisplayConnection} {
            return 0
        } else {
            return "result is $result and DisplayConnection is $DisplayConnection"
        }
        return 1
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT:629345
test tcl_unit_getProductPrefix {Unit test for proc getProductPrefix} {
    -setup {}
    -body {
       # source $testFile
        set pre1 [getProductPrefix $productName1]
        set pre2 [getProductPrefix $productName2]
        if {$pre1 == $productCode1 && $pre2 == $productCode2} {
            return 0
        }
        return 1
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT:629343
test tcl_unit_getSchemaVersionsPLSQL {Unit test for proc getSchemaVersionsPLSQL} {
    -constraints {}
    -setup {}
    -body {
        set result [getSchemaVersionsPLSQL $targetConnection]
        if {$result == $schemaVersion} {  return 0}
        return "returned: $result should be $schemaVersion"
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT:629351
test tcl_unit_getHeader {Unit test for proc getHeader with Header tag} {
    -setup {}
    -body {
        set results ""
        for {set i 1} {$i <= 3} {incr i} {
            set input_file [set Input_file$i]
            set output_file [set file_output$i]
            if [catch {set result [getHeader $input_file]} err] {
                return $err
            }
            if {$result != $output_file} {
                lappend results [list Sequence: $i  INPUT: Input file is: $input_file EXPECTED: $output_file RETURNED: $result]
            }
        }
        if {$results == ""} {
            return 0
        } else {
            return $results
        }
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}

#DVT:629347
test tcl_unit_getModFileVer {Unit test for fetching Model Version} {
    -setup {}
    -body {
        set result [getModFileVer $Model_Files_Path]
        regsub "V" $Mod_Ver "" Mod_Ver
        if {$result == $Mod_Ver} {
            return 0
        }
        return [list INPUT: $Model_Files_Path EXPECTED: $Mod_Ver RETURNED: $result]
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT:629344 - RE AT test for getSchemaProductPLSQL
test tcl_unit_getSchemaProductPLSQL {Unit test for proc getSchemaProductPLSQL} {
    -setup {}
    -body {
        set rval ""
        # If schema not present in the schema List get it from schema pool

        # checks the DBConnection is valid or invalid.
        if { [ catch { set dbx [ getLogonHandle $targetConnection ] } err] } {
            puts "ERROR: $err"
            puts "INFO: invalid username/password; logon denied"
            puts "INFO: Verify that your connection information is correct, and try again."
            exit
        }
        set result [getSchemaProductPLSQL $targetConnection]
        puts "Value of result is: $result"
        if {$result != $productName} {
            lappend rval "Sequence: 1 EXPECTED: $productName RETURNED: $result"
        }
        return $rval
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
# DVT 629364 - RE AT test for p_getArrayDatumAt
test tcl_unit_p_getArrayDatumAt {Unit test for proc p_getArrayDatumAt} {
    -setup {}
    -body {
        set modelTableIndex 0
        set modelkeyIndex 0
        global model
        array set model {TEXT_INDEXES.data {{{AUP_DESC DOMAIN CTXSYS.CONTEXT {SYNC (ON COMMIT) stoplist CTXSYS.EMPTY_STOPLIST STORAGE TEXT_STORAGE}}}} test {{test1 101} 202}}

        set result [p_getArrayDatumAt model TEXT_INDEXES $modelTableIndex $modelkeyIndex]

         if {$result == $temp} {
            return 0
        }
        return 1
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT: 629352
test tcl_unit_parseHeader {Unit test for Parsing an Headers} {
    -setup {}
    -body {
        set results ""
        set i 1
        source $Result
        foreach type $types {
            set headers [setTypes $type]
            foreach header $headers {
                array set temp1 [parseHeader $header $type]
            }
            set Diff [cmpArray temp1 [append type "_ARRAY"]]
            if {$Diff != ""} {
                lappend results [list Sequence: $i  INPUT: Headeris: $header Type is: $type EXPECTED: "" RETURNED: $Diff]
                incr i
            }
            unset temp1
        }
        if {$results == ""} {
            return 0
        } else {
            return $results
        }
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT: 629349
test tcl_unit_getMetaData {Unit test for getMetaData proc} {
    -setup {}
    -body   {
        source $Result
        set results ""
        set i 1
        foreach type $types {
            set temp $type
            foreach sourceType $sourceTypes {
                array set tempArray [getMetaData $Model_Files_Path $type $sourceType]
                if {$sourceType == "typeproc"} {
                    set Diff [cmpArray tempArray [append temp "_Typeproc"]]
                } elseif {$sourceType == "oldproc"} {
                    set Diff [cmpArray tempArray [append temp "_Oldproc"]]
                } elseif {$sourceType == "MODELFILES"} {
                    set Diff [cmpArray tempArray [append temp "_MODELFILES"]]
                } else {
                    lappend results [list Sequence: $i  INPUT: Model File path is: $Model_Files_Path Type is: $type Source Type is : $sourceType EXPECTED: "" RETURNED: $Diff]
                    incr i
                }
                set temp $type
                if {$Diff != ""} {
                    lappend results [list Sequence: $i  INPUT: Model File path is: $Model_Files_Path Type is: $type Source Type is : $sourceType EXPECTED: "" RETURNED: $Diff]
                    incr i
                }
            }
        }
        if {$results == ""} {
            return 0
        } else {
            return $results
        }
        return 1
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT: 629360
test tcl_unit_parseColumn {Unit test for parseColumn proc} {
    -setup {}
    -body {
        set results ""
        #Sourcing input/output array file
        source $Result
        updateInfo MODEL_FILES_DIRECTORY $MODEL_FILES_DIRECTORY
        setDefaultArray modelDef targetDef $modelConnection $targetConnection
        for {set i 1} {$i <= 2} {incr i} {
            set items [set item$i]
            # Calling parseColumn proc
            array set coldef [parseColumn $items]
            #Comparing actual values with expected values
            set Diff [cmpArray coldef [append coldef_output "coldef_output" "$i"]]
            set coldef_output ""
            if {$Diff != ""} {
                lappend results [list Sequence: $i INPUT: Item is: $items EXPECTED: "" RETURNED: $Diff]
            }
        }
            if {$results == ""} {
                return 0
            } else {
                return $results
            }
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT:629361
test tcl_unit_orderColumns {Unit test for orderColumns} {
    -setup {}
    -body {
        source $arrayInputOutputFile
        updateInfo MODEL_FILES_DIRECTORY $MODEL_FILES_DIRECTORY
        setDefaultArray modelDef targetDef $modelConnection $targetConnection
        array set outputResult [orderColumns $inputColumns $inputDefs]

        if {[array size outputResult] != [array size outputOrderColumns]} {
            return [list INPUT: inputColumns=$inputColumns,inputDefs=$inputDefs EXPECTED: [array size outputOrderColumns] RETURNED: [array size outputResult]]
        }

        if {[array size outputResult] == 0} {
            return [list INPUT: inputColumns=$inputColumns,inputDefs=$inputDefs EXPECTED: 0 RETURNED: [array size outputResult]]
        }

        set keys(outputResult) [lsort [array names outputResult]]
        set keys(outputOrderColumns) [lsort [array names outputOrderColumns]]
        set keys(keys) $keys(outputResult)

        if {![string equal $keys(outputResult) $keys(outputOrderColumns)]} {
            return [list INPUT: inputColumns=$inputColumns,inputDefs=$inputDefs EXPECTED: $keys(outputOrderColumns) RETURNED: $keys(outputResult)]
        }

        foreach key $keys(keys) {
            if {![string equal $outputResult($key) $outputOrderColumns($key)]} {
                return [list INPUT: inputColumns=$inputColumns,inputDefs=$inputDefs EXPECTED: $outputOrderColumns($key) RETURNED: $outputResult($key)]
            }
        }
        set rval 0
        array set outputResult1 [orderColumns $inputColumns1 $inputDefs1]
        foreach {key value} [array get outputResult1] {
            if {$outputOrderColumns2($key) != $value} {
                set rval [list INPUT: inputColumns=$inputColumns1,inputDefs=$inputDefs1 EXPECTED: $outputOrderColumns2($key) RETURNED: $value]
            }
            return $rval
        }
        return 0
    }
    -result { 0 }
}
# DVT 629364 - RE AT test for p_getArrayIndexFor
test tcl_unit_p_getArrayIndexFor {Unit test for proc p_getArrayIndexFor} {
    -setup {}
    -body {

        global target
        array set target {USER_TRIGGERS.header {AAC_ADVERSE_ACTION_CLASS AAD_ADB_ADDRESS_BOOK_ADDRESS AAT_ADE_APPEAL_TYPE ABF_ABNORMAL_FLAGS ACA_AUTH_CONDITION_CATEGORY}}

        foreach modelTable $modelList  {

            set targeTableIndex [p_getArrayIndexFor target USER_TRIGGERS $modelTable]
            set targetTable [lindex $target(USER_TRIGGERS.header) $targeTableIndex]

            if {$targetTable != $modelTable} {
                if {[lsearch $failed $modelTable] < 0} {
                return 1
                }
            }
            set flag 0
        }
        if {$flag == 0 } {
            return 0
        }
  }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT 629355 - RE AT test for makeSQLcols
test tcl_unit_makeSqlcols {Unit test for proc tcl_unit_makeSqlcols} {
    -setup {}
    -body {

           set retval ""
           set result ""

            for {set i 1} {$i <= $no_of_scenarios} {incr i} {
                set inpVar1 [set filetype$i]
                set inpVar2 [set argumentlist$i]
                set outVar [set item$i]

                set result [makeSQLcols $inpVar1 $inpVar2]

                if {$result != $outVar} {
                 lappend retval [list Sequence: $i INPUT: List is: $inpVar1 $inpVar2 EXPECTED: $outVar RETURNED: $result]
                }

                return $retval
            }
        }

    -result {  }
    -cleanup {dropAll dbCompare}
}
#DVT: 629354
test tcl_unit_parseSchemaValues {Unit test for parseSchemaValues proc} {
    -setup {}
    -body {
        set result ""
        foreach type $types {
            set headers [setTypes $type]
            foreach header $headers {
                array set temp [parseHeader $header $type]
            }
        }
        parseSchemaValues temp results $type $type_data
        if {$temp(USER_TABLES.header) == $actual_temp(USER_TABLES.header) && $temp(USER_TABLES.key) == $actual_temp(USER_TABLES.key) && $temp(USER_TABLES.data) == {}} {
            return 0
        } else {
            return [list Sequence: 1  INPUT: Results is $results Type : $type Type Data : $type_data EXPECTED: Header: $actual_temp(USER_TABLES.header) Key: $actual_temp(USER_TABLES.key) Data: $actual_temp(USER_TABLES.data) RETURNED: Header: $temp(USER_TABLES.header) Key: $temp(USER_TABLES.key) Data: $temp(USER_TABLES.data)]
        }
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
# DVT 629364 - RE AT test for p_getArrayDataFor
test tcl_unit_p_getArrayDataFor {Unit test for proc p_getArrayDataFor} {
    -setup {}
    -body {

        global model
        source $arrayFile

        foreach modelTable $modelArrayDataFor(USER_TRIGGERS.header)  {

        set result [p_getArrayDataFor modelArrayDataFor USER_TRIGGERS $modelTable]

        set i [lsearch $modelArrayDataFor(USER_TRIGGERS.header) $modelTable]
        set targetData [lindex $modelArrayDataFor(USER_TRIGGERS.data) $i]

         if {$targetData == $result} {
             return 0
        }
         return 1

        }

    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
# DVT 629363 - RE AT test for p_getArrayDatumFor
test tcl_unit_p_getArrayDatumFor {Unit test for proc p_getArrayDatumFor} {
    -setup {}
    -body {

        global model
        source $arrayFile
        set rval ""

        foreach modelTable $modelArrayDatumFor(USER_TRIGGERS.header)  {
            set i [lsearch $modelArrayDatumFor(USER_TRIGGERS.header) $modelTable]
            set keyValue [lindex $modelArrayDatumFor(USER_TRIGGERS.key) $i]
            set dataValue [lindex $modelArrayDatumFor(USER_TRIGGERS.data) $i]
            set result [p_getArrayDatumFor modelArrayDatumFor USER_TRIGGERS $modelTable $keyValue]

            if {$dataValue == $result} {
             set flag  0
            } else {
                lappend rval "Sequence: 1 EXPECTED: $dataValue RETURNED: $result "
            }
        }
        if {$rval != ""} {
                return $rval
            }
        if {$flag == 0} {
            return 0
        }
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}

#DVT:629356
test tcl_unit_getOldModels {Unit test for proc getOldModels} {
    -setup {}
    -body {
        source $sampleDataFile
        global modelDef
        global targetDef
        setInitialArrays
        set rval ""
        if [catch {
            getConnectionSetup modelDef $modelInputParam $MODEL_FILES_DIRECTORY
            getConnectionSetup targetDef $modelInputParam $MODEL_FILES_DIRECTORY
            getMetaDataSource modelDef targetDef
        } err] {
            return $err
        }

        array set modelDef [getMetaData "$MODEL_FILES_DIRECTORY/$modelInputParam" $utcfile oldproc]

        getOldModels modelDef "$MODEL_FILES_DIRECTORY/$modelInputParam/$utcfile" $tablesToCheck

        set sampleHeaderIndex [lsearch  [array get $sampleArray] header]
        set sampleHeaderList [lindex [array get $sampleArray] [incr sampleHeaderIndex]]

        set sampleDataIndex [lsearch  [array get $sampleArray] data]
        set sampleDataList [lindex [array get $sampleArray] [incr sampleDataIndex]]

        set sampleKeyIndex [lsearch  [array get $sampleArray] key]
        set sampleKeysList [lindex [array get $sampleArray] [incr sampleKeyIndex]]

        foreach header $tablesToCheck {
            set hI [lsearch -sorted $modelDef($utcfile.header) $header]
            if {$hI < 0} {
                lappend rval "Table $header not found in Model Definitions"
                continue
            }
            set keyValue [lindex $modelDef($utcfile.key) $hI]
            set dataValue [lindex $modelDef($utcfile.data) $hI]

            set sampleHI [lsearch $sampleHeaderList $header]
            if {$sampleHI < 0} {
                lappend rval "INPUT TABLE $header not found in test data"
                continue
            }
            set sampleDataVal [lindex $sampleDataList $sampleHI]
            set sampleKeyVal [lindex $sampleKeysList $sampleHI]

            if {$keyValue != $sampleKeyVal || $dataValue != $sampleDataVal} {
                lappend rval "INPUT TABLE: $header EXPECTED: $sampleKeyVal $sampleDataVal RETURNED: $keyValue $dataValue"
            }
        }
        return $rval
    }
    -result {}
    -cleanup {dropAll dbCompare}
}

#DVT:629357
test tcl_unit_getModel {Unit test for proc getModel} {
    -setup {}
    -body {
        source $sampleDataFile
        set rval ""
        global modelDef
        global targetDef
        setInitialArrays
        if [catch {
            getConnectionSetup modelDef $modelInputParam $MODEL_FILES_DIRECTORY
            getConnectionSetup targetDef $modelInputParam $MODEL_FILES_DIRECTORY
            getMetaDataSource modelDef targetDef
        } err] {
            return $err
        }
        array set modelDef [getMetaData "$MODEL_FILES_DIRECTORY/$modelInputParam" $utcfile MODELFILES]
        getModel modelDef "$MODEL_FILES_DIRECTORY/$modelInputParam/$utcfile" $tablesToCheck

        set sampleHeaderIndex [lsearch  [array get $sampleArray] header]
        set sampleHeaderList [lindex [array get $sampleArray] [incr sampleHeaderIndex]]

        set sampleDataIndex [lsearch  [array get $sampleArray] data]
        set sampleDataList [lindex [array get $sampleArray] [incr sampleDataIndex]]

        set sampleKeyIndex [lsearch  [array get $sampleArray] key]
        set sampleKeysList [lindex [array get $sampleArray] [incr sampleKeyIndex]]

        foreach header $tablesToCheck {
            set hI [lsearch -sorted $modelDef($utcfile.header) $header]
            if {$hI < 0} {
                lappend rval "INPUT TABLE: $header not found in Model Definitions"
                continue
            }
            set keyValue [lindex $modelDef($utcfile.key) $hI]
            set dataValue [lindex $modelDef($utcfile.data) $hI]

            set sampleHI [lsearch $sampleHeaderList $header]
            if {$sampleHI < 0} {
                lappend rval "INPUT TABLE: $header not found in test data"
                continue
            }
            set sampleDataVal [lindex $sampleDataList $sampleHI]
            set sampleKeyVal [lindex $sampleKeysList $sampleHI]

            if {$keyValue != $sampleKeyVal || $dataValue != $sampleDataVal} {
                lappend rval "INPUT TABLE: $header EXPECTED: $keyValue $dataValue RETURNED:$sampleKeyVal $sampleDataVal"
            }
        }
        return $rval
    }
    -result {}
    -cleanup {dropAll dbCompare}
}

#DVT: 629353 - Scenario for proc getDefinitions
test tcl_unit_getDefinitions {Unit test for proc getDefinitions} {
    -setup {}
    -body {
        global modelDef
        global targetDef
        source $TEST_HOME/testdata/Array_Input_Output.txt

        set rval ""

        if [catch {getConnectionSetup modelDef $modelInputParam $MODEL_FILES_DIRECTORY} err] {
            return $err
        }
        if [catch {getConnectionSetup targetDef $modelInputParam $MODEL_FILES_DIRECTORY} err] {
            return $err
        }
        if [catch {getMetaDataSource modelDef targetDef} err] {
            return $err
        }

        array set modelDef [getMetaData "$MODEL_FILES_DIRECTORY/$modelInputParam" $utcfile $sourceType]
        array set modelDef {$utcfile.header {} $utcfile.key {} $utcfile.data {}}

        if {$type == "MODELFILES"} {
            if {$TABLES == "NULL"} {
            set TABLES ""
            }

            getDefinitions modelDef $TABLES

            set hI [lsearch $modelDef($utcfile.header) $header]
            set keyValue [lindex $modelDef($utcfile.key) $hI]
            set dataValue [lindex $modelDef($utcfile.data) $hI]

            if {$keyValue != $keyValue_MODELFILES && $dataValue != [subst $$refDataVal]} {
                lappend rval "SEQUENCE: 1\nEXPECTED KEY VALUE: $keyValue_MODELFILES\nEXPECTED DATA VALUE: [subst $$refDataVal]\nRETURNED KEY VALUE: $keyValue\nRETURNED DATA VALUE: $dataValue"
            }
        } else {
            getDefinitions modelDef $utcfile

            set hI [lsearch $modelDef($utcfile.header) $header]
            set keyValue [lindex $modelDef($utcfile.key) $hI]
            set dataValue [lindex $modelDef($utcfile.data) $hI]

            if {$keyValue != [subst $$refKeyVal] && $dataValue != [subst $$refDataVal]} {
                lappend rval "SEQUENCE: 2\nEXPECTED KEY VALUE: [subst $$refKeyVal]\nEXPECTED DATA VALUE: [subst $$refDataVal]\nRETURNED KEY VALUE: $keyValue\nRETURNED DATA VALUE: $dataValue"
            }
        }
        return $rval
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}

#DVT: 629365 - RE AT  test for updateArrayData
test tcl_unit_updateArrayData {Unit test for proc updateArrayData} {
    -setup {}
    -body {

        set retval ""
        set result ""
        # Defined two Arrays targetP and  updateArray in  Array_Input_Output.txt file
            source $ArraySample

        foreach header $targetP(USER_TRIGGERS.header) {

            set  Index [lsearch $targetP(USER_TRIGGERS.header) $header]
            set  table1 [lindex $targetP(USER_TRIGGERS.header) $Index]

            # Calling updateArrayData
            updateArrayData targetP USER_TRIGGERS $table1 "" "AFTER EACH ROW $Index"

        }

       if {$targetP(USER_TRIGGERS.data) != $updateArray(USER_TRIGGERS.data)} {
          lappend retval [list EXPECTED: $updateArray(USER_TRIGGERS.data) RETURNED: $targetP(USER_TRIGGERS.data)]
        }

        return $retval

    }
     -result {  }
     -cleanup {dropAll dbCompare}
}

# DVT 629358 - RE AT  test for queryModel
test tcl_unit_queryModel {Unit test for proc queryModel} {
    -setup {}
    -body {
        source $sampleDataFile
        global modelDef
        global targetDef
        setInitialArrays
        if [catch {
            getConnectionSetup modelDef $modelInputParam $MODEL_FILES_DIRECTORY
            getConnectionSetup targetDef $modelInputParam $MODEL_FILES_DIRECTORY
            getMetaDataSource modelDef targetDef
        } err] {
            return $err
        }
        array set modelDef [getMetaData "$MODEL_FILES_DIRECTORY/$modelInputParam" $utcfile MODELFILES]
        queryModel modelDef "$MODEL_FILES_DIRECTORY/$modelInputParam/$utcfile" $tableToCheck ""

        set sampleHeaderIndex [lsearch  [array get $sampleArray] header]
        set sampleHeaderList [lindex [array get $sampleArray] [incr sampleHeaderIndex]]

        set sampleDataIndex [lsearch  [array get $sampleArray] data]
        set sampleDataList [lindex [array get $sampleArray] [incr sampleDataIndex]]

        set sampleKeyIndex [lsearch  [array get $sampleArray] key]
        set sampleKeysList [lindex [array get $sampleArray] [incr sampleKeyIndex]]

        if {[lsearch -sorted $modelDef($utcfile.header) $tableToCheck] != 0} {
            return "INPUT TABLE: $header not found in Model Definitions"
        }
        set keyValue [lindex $modelDef($utcfile.key) 0]
        set dataValue [lindex $modelDef($utcfile.data) 0]

        set sampleHI [lsearch $sampleHeaderList $tableToCheck]
        if {$sampleHI < 0} {
            return "INPUT TABLE: $header not found in test data"
        }
        set sampleDataVal [lindex $sampleDataList $sampleHI]
        set sampleKeyVal [lindex $sampleKeysList $sampleHI]

        if {$keyValue != $sampleKeyVal || $dataValue != $sampleDataVal} {
            return "INPUT: Mod3100 EXPECTED: $sampleKeyVal $sampleDataVal RETURNED: $keyValue $dataValue"
        }
    }
    -result {}
    -cleanup {dropAll dbCompare}
}

# DVT 629346 - RE AT  test for getVersionModel
test tcl_unit_getVersionModel {Unit test for proc getVersionModel} {
    -setup {}
    -body {
        # Scenario 1: Happy case
        # Scenario 2: SchemaVersion not present in the AutoConversion.txt
        # Scenario 3: Incorrect path for Models Dir
        # Scenario 4: Missing schema version
        set rval ""
        for {set i 1} {$i <= $totalCases} {incr i} {
            set modDirsPath [set modPath$i]
            set schemaVersion [set schVer$i]
            set exp [set modDir$i]
            if {[getVersionModel $modDirsPath $schemaVersion] != $exp} {
                lappend rval [list INPUT: Model directory path-$modDirsPath Schema Version-$schemaVersion EXPECTED: $exp RETURNED: [getVersionModel modDirsPath $schemaVersion]]
            }
        }
        if {$rval != ""} {return $rval}
    }
    -result {}
    -cleanup {dropAll dbCompare}
}
# DVT 633429 - RE AT test for arraytoList
test tcl_unit_arraytoList {Unit test for proc arraytoList} {
    -setup {}
    -body {
            set retval ""
            set result ""
            source $ArraySample

            foreach key [array names Atol] {

                set result "${key}=$Atol($key)"
                set returnValue [arraytoList Atol $key]

                if {$result != $returnValue} {
                 lappend retval [list EXPECTED: $result RETURNED: $returnValue]
                }
            }

            return $retval

        }

    -result {  }
    -cleanup {dropAll dbCompare}
}
#DVT: 633592
test tcl_unit_p_compareTables {Unit test for p_compareTables proc} {
    -setup {}
    -body {
        set results ""
        updateInfo MODEL_FILES_DIRECTORY $MODEL_FILES_DIRECTORY
        setDefaultArray modelDef targetDef $modelConnection $targetConnection
        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            set modelHeader [set model_header$i]
            set targetHeader [set target_header$i]
            set modelKey [set model_key$i]
            set targetKey [set target_key$i]
            set expectedResult [set expected_Result$i]
            set modelDef(USER_TABLES.header) $modelHeader
            set targetDef(USER_TABLES.header) $targetHeader
            set modelDef(USER_TABLES.key) $modelKey
            set targetDef(USER_TABLES.key) $targetKey
            # Calling proc p_comparetables and it will return the differences
            set result [p_compareTables targetDef modelDef]
            if {$result != $expectedResult} {
                lappend results [list Sequence: $i  INPUT: Model Header: $modelHeader Target Header: $targetHeader Model Key: $modelKey Target Key: $targetKey EXPECTED: $expectedResult RETURNED: $result]
            }
            set modelDef(USER_TABLES.header) $modelHeader
            set targetDef(USER_TABLES.header) $targetHeader
            set modelDef(USER_TABLES.key) $modelKey
            set targetDef(USER_TABLES.key) $targetKey
        }
            return $results
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
#DVT: 633593
test tcl_unit_CleanString {Unit test for CleanStrings proc} {
    -setup {}
    -body {
        set results ""
        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
        set sql_statment [set sql_query$i]
        set expected [set expected_Result$i]
        # This UT proc check if cleanQuery proc is removing all the extra spases, tabs,  "{", "}" etc from sql query passed
            set result [CleanString $sql_statment]
            if {$result != $expected} {
                lappend results [list Sequence: $i  INPUT: SQL query is : $sql_statment EXPECTED: $expected RETURNED: $result]
            }
        }
        if {$results == ""} {
            return 0
        } else {
            return $results
        }
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT: 633594
test tcl_unit_checkBackTables {Unit test for checkBackTables proc} {
    -setup {}
    -body {
        set message ""
        set results ""
        set i 1

        #calling proc getLogonHandle to create database handler
        set dbh [getLogonHandle $targetConnection]
        if {$checkBackTables_names == "positive"} {
        # Scenario when no back table exists in schema
            catch {checkBackTables $dbh} err
                if {$err != $expected_Result} {
                    append message $err
                }
            if {$message == $expected_Result} {
                return 0
            } else {
                lappend results [list Sequence: $i  INPUT: DBH is : $dbh EXPECTED: $expected_Result RETURNED: $err]
                incr i
            }
        } else {
        # Scenario when back table exists in schema
            set SQL "CREATE TABLE $BACKTABLE"
            execsql use $dbh $SQL
            if [catch {set result [checkBackTables $dbh]} err] {
                return $err
            }
            if {[regexp $expected_Result $result]} {
                set err 0
            } else {
                lappend results [list Sequence: $i  INPUT: DBH is : $dbh BACKTABLE is: $DELETETABLE EXPECTED: $expected_Result RETURNED: $err]
                incr i
            }
            set SQL "DROP TABLE $DELETETABLE"
            execsql use $dbh $SQL
        }
            if {$results == ""} {
                return 0
            } else {
                return $results
            }
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
# DVT 633430 - RE AT test for setTypes
test tcl_unit_setTypes {Unit test for proc setTypes} {
    -setup {}
    -body {
        source $arrayFile
        set rval ""

        set sampleHeaderIndex [lsearch  [array get sampleHeadersForsetTypes] tempheaders]
        set sampleHeaderList [lindex [array get sampleHeadersForsetTypes] [incr sampleHeaderIndex]]

        set sampleDataIndex [lsearch  [array get sampleHeadersForsetTypes] tempheadersData]
        set sampleDataList [lindex [array get sampleHeadersForsetTypes] [incr sampleDataIndex]]

        set sampleHI [lsearch $sampleHeaderList $headersToCheck]
        if {$sampleHI > 0} {
            lappend rval "The header index is returned as negative. Value of sample header index: $sampleHI"
        }
        set sampleDataVal [lindex $sampleDataList $sampleHI]

        set headers [setTypes $type]

        if {$headers != $sampleDataVal} {
            lappend rval "Sequence: 1 EXPECTED: $sampleDataVal RETURNED: $headers"
        }
        if {$rval != ""} {
            return $rval
        }
        return 0
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}

# DVT 633596 - RE AT test for setOldTypes
test tcl_unit_setOldTypes {Unit test for proc setOldTypes} {
    -setup {}
    -body {
        source $arrayFile
        set rval ""

        set sampleHeaderIndex [lsearch  [array get sampleHeadersForsetOldTypes] tempheaders]
        set sampleHeaderList [lindex [array get sampleHeadersForsetOldTypes] [incr sampleHeaderIndex]]

        set sampleDataIndex [lsearch  [array get sampleHeadersForsetOldTypes] tempheadersData]
        set sampleDataList [lindex [array get sampleHeadersForsetOldTypes] [incr sampleDataIndex]]

        set sampleHI [lsearch $sampleHeaderList $headersToCheck]
        if {$sampleHI < 0} {
             lappend rval "The header index is returned as negative. Value of sample header index: $sampleHI"
        }
        set sampleDataVal [lindex $sampleDataList $sampleHI]

        set headers [setOldTypes $type]

        if {$headers != $sampleDataVal} {
            lappend rval "Sequence: 1 EXPECTED: $sampleDataVal RETURNED: $headers"
        }
        if {$rval != ""} {
            return $rval
        }
        return 0
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}

# DVT 633682 - RE AT test for dbc_getArrayIndexFor
# This test is to verify the condition of the proc when key is passed as null.
test tcl_unit_dbc_getArrayIndexFor_1.1 {Unit test for proc dbc_getArrayIndexFor} {
    -setup {}
    -body {
        global target
        source $arrayFile
        set rval ""

        foreach modelTable $modelList  {

        set targeTableIndex [dbc_getArrayIndexFor targetDBC USER_TRIGGERS $modelTable ""]
        set targetTable [lindex $targetDBC(USER_TRIGGERS.header) $targeTableIndex]

        if {$targetTable != $modelTable} {
            lappend rval "Scenario getArrayIndexFor_1.1 is failed.\nExpected result :$modelTable\nReturned value: $targetTable\n"
        }
        set flag 0
        }
        if {$rval != ""} {
            return $rval
        }
        if {$flag == 0 } {
        return 0
        }
  }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}

# DVT 633682 - RE AT test for dbc_getArrayIndexFor
# This test is to verify the condition of the proc when key is passed as an input parameter.
test tcl_unit_dbc_getArrayIndexFor_1.2 {Unit test for proc dbc_getArrayIndexFor} {
    -setup {}
    -body {
        global target
        source $arrayFile

        foreach modelTable $modelList  {

            foreach key $keysList {

                set targeTableIndex [dbc_getArrayIndexFor target USER_TRIGGERS $modelTable $key]
                set targetTableHeader [lindex $target(USER_TRIGGERS.header) $targeTableIndex]
                set tagetTableKey [lindex $target(USER_TRIGGERS.key) $targeTableIndex]

                if {$targetTableHeader != $modelTable} {
                    if {$tagetTableKey != $key} {
                        set flag 1
                    }
                }
            }

          set flag 0
        }
        if {$flag == 0 } {
        return 0
        }
  }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}


# DVT 633682 - RE AT test for dbc_getArrayIndexFor
# This test is to verify the negative condition of the proc when an additional table is there in the modelList.
test tcl_unit_dbc_getArrayIndexFor_1.3 {Unit test for proc dbc_getArrayIndexFor} {
    -setup {}
    -body {
        global target
        source $arrayFile
        set rval ""

        foreach modelTable $modelList  {

        set targeTableIndex [dbc_getArrayIndexFor targetDBC USER_TRIGGERS $modelTable ""]
        set targetTable [lindex $targetDBC(USER_TRIGGERS.header) $targeTableIndex]

        if {$targetTable != $modelTable} {
        # For negtive scenario, make the below "if" condition equals to zero.
            if {[lsearch $failed $modelTable] == 0} {
            return 0
            } else {
            lappend rval "Scenario getArrayIndexFor_1.3 (negative) is failed. Expected value is equals to Returned value.\nExpected Value:$modelTable\nReturned Value: $targetTable\n"
            }
        }
        set flag 0
        }
        if {$rval != ""} {
            return $rval
        }
        if {$flag == 0 } {
        return 0
        }
  }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT:633351
test tcl_unit_addResult {Unit test for proc addResult} {
    -setup {}
    -body {
        setNullResults
        #Add a key-value to RESULTS, verify this addition and that no increment took place
        addResult $inputParam $inputVal1
        if {![info exists RESULTS($inputParam)] || ($RESULTS($inputParam) != $result1) || ($RESULTS(number_of_changes) != 0) } { return "INPUT: $inputParam - $inputVal1 EXPECTED: $result1 AND RESULTS(number_of_changes)=0 RETURNED: $RESULTS($inputParam) AND RESULTS(number_of_changes)=$RESULTS(number_of_changes)"}
        #Add a key-value to RESULTS, verify this addition and that an increment took place
        addResult $inputParam $inputVal2 1
        if {![info exists RESULTS($inputParam)] || ($RESULTS($inputParam) != $result2) || ($RESULTS(number_of_changes) != 1) } { return "INPUT: $inputParam - $inputVal2 EXPECTED: $result2 AND RESULTS(number_of_changes)=1 RETURNED: $RESULTS($inputParam) AND RESULTS(number_of_changes)=$RESULTS(number_of_changes)"}
        #Verify a subsequent increment
        addResult $inputParam $inputVal2 1
        if {![info exists RESULTS($inputParam)] || ($RESULTS($inputParam) != $result3) || ($RESULTS(number_of_changes) != 2) } { return "INPUT: $inputParam - $inputVal2 EXPECTED: $result3 AND RESULTS(number_of_changes)=2 RETURNED: $RESULTS($inputParam) AND RESULTS(number_of_changes)=$RESULTS(number_of_changes)"}
    }
    -result {}
    -cleanup {dropAll dbCompare}
}
#DVT:633760
test tcl_unit_getResults {Unit test for proc getResults} {
    -setup {}
    -body {
        source $sampleDataFile
        global RESULTS
        set retVal ""
        if {$testType == "NEGATIVE"} {
        # Verify that getResults throws error if RESULTS array is empty
            if {[catch {getResults $inputParam}] != 0} {
                array set RESULTS [array get $sampleResultsArray]
                # Verify that "getResults *" yields the complete RESULTS array
                if {[getResults *] != [array get RESULTS]} {
                    lappend retVal "INPUT: * EXPECTED: [array get RESULTS] RETURNED: [getResults *]"
                }
                # Verify that "getResults all" yields the complete RESULTS array
                if {[getResults all] != [array get RESULTS]} {
                    lappend retVal "INPUT: all EXPECTED: [array get RESULTS] RETURNED: [getResults *]"
                }
                # Verify that "getResults ADD.TABLES" yields the appropriate value from RESULTS array
                if {[getResults ADD.TABLES] != $RESULTS(ADD.TABLES)} {
                    lappend retVal "INPUT: ADD.TABLES EXPECTED: $RESULTS(ADD.TABLES) RETURNED: [getResults ADD.TABLES]"
                }
            } else {
                lappend retVal "INPUT: Empty RESULTS array EXPECTED: Error RETURNED: No Error observed"
            }
        } else {
            array set RESULTS [array get $sampleResultsArray]
            # Verify that getResults yields an error for a non-existant value
            if [catch {getResults NonExistantValue} err] {
                if {$err != "type - NonExistantValue"} {
                    lappend retVal "INPUT: [array get RESULTS] EXPECTED: type - NonExistantValue RETURNED: No Error observed"
                }
            } else {
                lappend retVal "INPUT: [array get RESULTS] EXPECTED: type - NonExistantValue RETURNED: No Error observed"
            }
        }
        return $retVal
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
#DVT: 633783
test tcl_unit_execSQL1.1 {Unit test for execSQL proc that tests Insert and Select query execution} {
    -setup {}
    -body {
        #Calling execsQL to insert values in Test table
        if [catch {execSQL use $tdbh $sql_insert} err] {
            return $err
        }
        #Calling execsQL to fetch the data from Test table
        catch {execSQL use $tdbh $sql} err
        set result $db_result
        if {$result == $expected_Result} {
            return 0
        }
            return 1
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT: 633783
test tcl_unit_execSQL1.2 {Unit test for execSQL proc that tests Update and Delete query execution} {
    -setup {}
    -body {
        #Calling execsQL to Update values in Test table
        if [catch {execSQL use $tdbh $sql_update} err] {
            return $err
        }
        #Calling execsQL to fetch the data from Test table
        catch {execSQL use $tdbh $sql} err
        set result $db_result
        #Calling execsQL to delete the inserted data
        if [catch {execSQL use $tdbh $sql_delete} err] {
            return $err
        }
        if {$result == $expected_Result} {
            return 0
        }
            return 1
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT: 633783
test tcl_unit_execSQL1.3 {Unit test for execSQL proc that tests incorrect query execution} {
    -setup {}
    -body {
        #Calling proc execSQL to execute incorrect SQL Query
        catch {execSQL use $tdbh $sql} err
        # err will return 0 and 100 if sql query is not correct
        if {($err == 0 || $err == 100)} {
            return 0
            error "SQL failure."
        }
        set result $db_result
        if {$result == $expected_Result} {
            return 0
        }
            return 1
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
# DVT 633875 - TE AT test for getMinType
test tcl_unit_getMinType {Unit test for proc getMinType} {
    -setup {}
    -body {
        source $arrayFile
        set rval ""

        if {$getMinType != "negative"} {
            for {set i 1} {$i <= 5} {incr i} {
                set inputType [set type$i]
                set results [getMinType $inputType sampleModel sampleTarget]
                set sampleTargetDataList $sampleTarget(DEF.$inputType.data)
                set sampleModelDataList $sampleModel(DEF.$inputType.data)
                set output $sampleModelDataList

                if {$results != $output} {
                    lappend rval "Sequence: $i Case Type: $getMinType\nEXPECTED: $output\nRETURNED: $results"
                }
                unset results
            }
        } else {
            catch {set results [getMinType $type6 sampleModel sampleTarget]} errs
            if {$errs != $ErrorInfo} {
                lappend err "Sequence: $i Case Type: $getMinType\nEXPECTED: $ErrorInfo\nRETURNED: $errs"
            }
        }
        if {$rval != ""} {
            return $rval
        }
        return 0
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT: 633878
test tcl_unit_findDriverFile {Unit test for findDriverFile proc} {
    -setup {}
    -body {
        set results ""
        for {set i 1} {$i <= $number_of_scenarios} {incr i} {
            set flag 0
            set driverFile [set driver_File$i]
            set currentMod_Dir [set currentModDir$i]
            set expectedResult [set expected_Result$i]
            #if driver file does not exist create it
            if { [file exists $driverFile] != 1 && $driverFile != ""} {
                set flag 1
                set fp [open $driverFile w+]
                close $fp
            }
            #Calling proc findDriverFile to find the current Mod Dir
            if [catch {set result [findDriverFile $currentMod_Dir]} err] {
                return $err
            }
            if {$result == $expectedResult} {
                if {$flag == 1} {
                    file delete -force $driverFile
                }
            } else {
                if {$flag == 1} {
                    file delete -force $driverFile
                }
                lappend results [list Sequence: $i  INPUT: Driver File: $driverFile Working dir : $currentMod_Dir EXPECTED: $expectedResult RETURNED: $result]
            }
        }
            if {$results == ""} {
                return 0
            } else  {
                return $results
            }
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}

# DVT 633872 - RE AT test for getMinTypeList
test tcl_unit_getMinTypeList {Unit test for getMinTypeList proc} {
    -setup {}
    -body {
        source $arrayFile
        set rval ""

        if {$getMinTypeList == "negative"} {

            for {set i 1} {$i <= 2} {incr i} {

                # Scenario where the data value in the modelDef or targetDef is less
                array set modelDef [array get sampleModelMinTypeList$i]
                array set targetDef [array get sampleTargetMinTypeList$i]

                set results [getMinTypeList $type]

                set sampleTargetDataList $targetDef(DEF.$type.data)
                set sampleModelDataList $modelDef(DEF.$type.data)

                if {$i == 1} {
                    set output $sampleModelDataList
                } else {
                    set output $sampleTargetDataList
                }
                if {$results != $output} {
                    lappend rval "Sequence: $i Case Type:$getMinTypeList\nEXPECTED: $output\nRETURNED: $results"
                }
                array unset modelDef
                array unset targetDef
            }
        }   else {
                # Scenario where all data list is available in both the modelDef and targetDef
                array set modelDef [array get sampleModelMinTypeList3]
                array set targetDef [array get sampleTargetMinTypeList3]

                set results [getMinTypeList $type]
                set sampleTargetDataList $targetDef(DEF.$type.data)
                set sampleModelDataList $modelDef(DEF.$type.data)

                set output $sampleModelDataList

                if {$results != $output} {
                    lappend rval "Sequence: 3 Case Type: $getMinTypeList\nEXPECTED: $output\nRETURNED: $results"
                }
            }
            if {$rval != ""} {
                return $rval
        }
        return 0
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT:633873
test tcl_unit_compareTableColumns {Unit test for proc compareTableColumns} {
    -setup {}
    -body {
        source $sampleDataFile
        set err ""
        # Test 1: Model & target arrays are the same
        # Test 2: Verify that the exact differences are found with following scenarios:
        # a. TargetDef is missing a column
        # b. ModelDef has an extra column
        # Test 3: Verify that the exact differences are found when:
        # a. ModelDef is missing a column
        # b. TargetDef has an extra column

        for {set i 1} {$i <= $totalCases} {incr i} {
            global modelDef targetDef
            setNullResults
            set mDef [set sampleModelArray$i]
            set tDef [set sampleTargetArray$i]
            set resultDef [set sampleResult$i]
            array set modelDef [array get $mDef]
            array set targetDef [array get $tDef]
            compareTableColumns modelDef targetDef
            if {([getResults ADD.COLUMNS] != [lindex [array get $resultDef ADD.COLUMNS] 1]) || ([getResults ADD.TABLES] != [lindex [array get $resultDef ADD.TABLES] 1]) || !(([getWarnings MODIFY.COLUMNS] == [lindex [array get $resultDef MODIFY.COLUMNS] 1]) || ([getResults MODIFY.COLUMNS] == [lindex [array get $resultDef MODIFY.COLUMNS] 1]))} {
                lappend err "EXPECTED: ADD.COLUMNS-[lindex [array get $resultDef ADD.COLUMNS] 1]ADD.TAB_COLS-[lindex [array get $resultDef ADD.TAB_COLS] 1] MODIFY.COLUMNS-[lindex [array get $resultDef MODIFY.COLUMNS] 1]   \nRETURNED: ADD.COLUMNS-[getResults ADD.COLUMNS] ADD.TAB_COLS-[getResults ADD.TAB_COLS] MODIFY.COLUMNS(Warnings)-[getWarnings MODIFY.COLUMNS] MODIFY.COLUMNS(Results)-[getResults MODIFY.COLUMNS]"
            }
            unset modelDef targetDef RESULTS
        }
        return $err
    }
    -result {}
    -cleanup {dropAll dbCompare}
}
#DVT: 634056
test tcl_unit_getCurrentDriverRow {Unit test for getCurrentDriverRow proc} {
    -setup {}
    -body {
        set results ""
        for {set i 1} {$i <= 2} {incr i} {
            set driver_File [set driverFile$i]
            set current_Version [set currentVersion$i]
            set expectedResult [set expected_Result$i]
            set current_Product [set currentProduct$i]
            if {$getCurrentDriverRow_info == "positive"} {
                #calling getCurrentDriverRow to get the matching line from Driver File
                if [catch {set result [getCurrentDriverRow $driver_File $current_Version $current_Product]} err] {
                    return $err
                }
                regsub {^[\d]+ } $result "" result
                if {$result != $expectedResult} {
                    lappend results [list Sequence: $i  INPUT:  EXPECTED: $expectedResult RETURNED: $result]
                }
            } else {
                #calling getCurrentDriverRow to get the matching line from Driver File
                if [catch {set result [getCurrentDriverRow $driver_File $current_Version $current_Product]} err] {
                    if {$err != $expectedResult} {
                        lappend results [list Sequence: $i  INPUT: Driver File: $driver_File Current Version: $current_Version Current Product: $current_Product EXPECTED: $expectedResult RETURNED: $err]
                    }
                }
            }
        }
        if {$results == ""} {
            return 0
        } else {
            return $results
        }
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
# DVT 634061 - RE AT test for getLogonHandle
test tcl_unit_getLogonHandle {Unit test for getLogonHandle proc} {
    -setup {}
    -body {
        set results ""
        set rval ""
        if {$getLogOn_case != "negative"} {
            # If schema not present in the schema List get it from schema pool
        # Scenario 1: Passing correct connection String
            set results [getLogonHandle $targetConnection]
            if {$results != $output} {
            lappend rval "Case Type: $getLogOn_case\nEXPECTED: $output\nRETURNED: $results"
            }
        } else {
        # Scenario 2: Passing incorrect connection String
            catch {getLogonHandle $connectionString} err
            if {![regexp $output $err]} {
                lappend rval "Case Type: $getLogOn_case\nEXPECTED:$output\nRETURNED:$err"
            }
        }
        if {$rval != ""} {
            return $rval
        }
        return 0
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT:633964
test tcl_unit_compareTableLists {Unit test for proc compareTableLists} {
    -setup {}
    -body {
        set retVal ""
        # 1:Test for scenario where Model list has more tables than the Target list
        # 2:Test for scenario where Model list has fewer elements than the Target list
        # 3:Test for scenario where both lists are empty
        # 4:Test for scenario where both lists are the same
        # 5:Test for scenario where Model & Target lists have different elements but the count is same
        for {set i 1} {$i <= $totalCases} {incr i} {
            set modelDef [set sampleModel$i]
            set targetDef [set sampleTarget$i]
            set resultDef [set sampleOutput$i]
            set output [compareTableLists $modelDef $targetDef]
            if {[llength $output] != 2 || !([string equal [lindex $output 0] [lindex $resultDef 0]] && [string equal [lindex $output 1] [lindex $resultDef 1]])} {
                lappend retVal "SEQUENCE: $i INPUT: Model-$modelDef Target-$targetDef  EXPECTED: $resultDef  RETURNED: $output"
            }
        }
        return $retVal
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}

#DVT: 634075
test tcl_unit_getCurrentDriverRows {Unit test for getCurrentDriverRows proc} {
    -setup {}
    -body {
        set results ""
        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            set driver_File [set driverFile$i]
            set current_Version [set currentVersion$i]
            set expectedResult [set expected_Result$i]
            set current_Product [set currentProduct$i]
            if {$getCurrentDriverRows_info == "positive"} {
                #calling getCurrentDriverRows to get the matching line from Driver File
                if [catch {set result [getCurrentDriverRows $driver_File $current_Version $current_Product]} err] {
                    return $err
                }
                foreach r $result er $expectedResult {
                    regsub {^[\d]+ } $r "" r
                    if {$r != $er} {
                        lappend results [list Sequence: $i  INPUT: $er RETURNED: $r]
                    }
                }
            } else {
                #calling getCurrentDriverRows to get the matching line from Driver File
                if [catch {set result [getCurrentDriverRows $driver_File $current_Version $current_Product]} err] {
                    if {$err != $expectedResult} {
                        lappend results [list Sequence: $i  INPUT: Driver File: $driver_File Current Version: $current_Version Current Product: $current_Product EXPECTED: $expectedResult RETURNED: $err]
                    }
                }
            }
        }
        if {$results == ""} {
            return 0
        } else {
            return $results
        }
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
# DVT 634095 - RE AT test for getLines
test tcl_unit_getLines {Unit test for getLines proc} {
    -setup {}
    -body {
        set rval ""
        # Scenario 1 :  if the file has blank rows at beginning and end , they should not be in the list returned. Also if the file has the blank line inbetween 2 or more lines, they should be returned in the list as a blank
        if [catch {set data [getLines $filename]} err] {
            return $err
        }
        foreach result $data myResult $testData {
            if {$result!=$myResult} {
            lappend rval "Scenario 1 Failed.\nExpected Value --> $myResult\nReturned Value --> $result "
            }
        }

        # Scenario 2 : When incorrect filename is passed
        unset data
        if [catch {set data [getLines $errorFileName]} err] {
            if {$err != $getLinesException1} {
                lappend rval "Scenario 2 Failed.\nExpected Value --> $getLinesException1\nReturned Value --> File $err"
            }
        }

        # Scenario 3 : When a directory name is passed
        if [catch {set data [getLines [pwd]]} err] {
            if {$err != $getLinesException2} {
            lappend rval "Scenario 3 Failed.\nExpected Value --> $getLinesException2\nReturned Value --> $err"
            }
        }

        # Scenario 4 : Matching the length of the list of actual and expected.
        if [catch {set data [getLines $filename]} err] {
            lappend rval $err
        }
        set strLength [string length $data]
                if {$strLength != $expStrLngth} {
                    lappend rval "Scenario 4 Failed.\nExpected Value --> $expStrLngth\nReturned Value --> $strLength"
                }
        return $rval
    }
    -result {}
    -cleanup {dropAll dbCompare}
}
#DVT: 634221
test tcl_unit_setInfo {Unit test for setInfo proc} {
    -setup {}
    -body {
        set rval ""
        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            set set_name [set name$i]
            set set_value [set value$i]
            set expectedResult [set expected_Result$i]
            #Calling setinfo proc to set the value in global Array DBS_INFO
            if [catch {set result [setInfo $set_name $set_value]} err] {
                if {$err == $expectedResult && $DBS_INFO($set_name) == $expectedResult} {
                    continue
                } else {
                    lappend rval [list Sequence: $i  INPUT: Name: $set_name Value: $set_value EXPECTED: $expectedResult RETURNED: $err]
                    continue
                }
            }
            if {$result != $expectedResult || $DBS_INFO($set_name) != $expectedResult} {
                lappend rval [list Sequence: $i  INPUT: Name: $set_nam Value: $set_value EXPECTED: $expectedResult RETURNED: $DBS_INFO($set_name)]
            }
        }
        return $rval
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
# DVT - 634091 RE AT test for getDriverInfo
test tcl_unit_getDriverInfo {Unit test for getDriverInfo proc} {
    -setup {}
    -body {
        set rval ""

        # Calling proc getCurrentDriverRow to check any random value from the AutoConversion.txt
        if [catch {set DriverVersion [getCurrentDriverRow $driverFile $currentVersion]} err] {
            return $err
        }
        # Calling proc getDriverInfo to read the autoconversion.txt file and append in a list form
        if [catch {set data [getDriverInfo $driverFile]} err] {
            return $err
        }
        # Setting up the value at 0 index from DriverVersion variable
        set dvValue [lindex $DriverVersion 0]

        # Setting up the index value of the DriverVersionValue.
        set dvIndex [lsearch [lindex $data 0] $dvValue]
        set i 0

        foreach dv $DriverVersion {
            if {$dv != [lindex [lindex $data $i] $dvIndex]} {
                lappend rval "Sequence: 1\nEXPECTED:[lindex [lindex $data $i] $dvIndex] $\nRETURNED: $dv"
            }
            incr i
        }
            return $rval
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
#DVT: 634093
test tcl_unit_getInfo {Unit test for getInfo proc} {
    -setup {}
    -body {
        set results ""
        if {$getInfo_type == "positive"} {
            #Calling proc setinfo to set the value in global Array DBS_INFO
            if [catch {set val [setInfo $name $value]} err] {
                return $err
            }
            #Calling proc getinfo to get the value from global Array DBS_INFO
            if [catch {set result [getInfo $name]} err] {
                return $err
            }
            if {$result != $expected_Result && $DBS_INFO($name) != $expected_Result} {
                lappend results [list Sequence: 1  INPUT: Name: $name Value: $value EXPECTED: $expected_Result RETURNED: $result]
            }
        } else {
            #Calling proc getinfo to get the value from global Array DBS_INFO
            if [catch {set result [getInfo $name]} err] {
                return $err
            }
            if {$result != $expected_Result} {
                lappend results [list Sequence: 1  INPUT: Name: $name EXPECTED: $expected_Result RETURNED: $result]
            }
        }
            return $results
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
#DVT: 634065
test tcl_unit_checkModelFileResources {Unit test for checkModelFileResources proc} {
    -setup {}
    -body {
        set result ""
        #Calling proc checkModelFileResources
        if {[file exists $path/$modDir]} {
            catch {file rename $path/$modDir $path/TEMP$modDir} result
        } else {
            set result "Test is invalid.  model file $path/$modDir should exist in package but doesn't"
        }
        if {$result == ""} {
            set conversionInfo [getLines $autoTextFile]
            set result [checkModelFileResources $conversionInfo $path]
            if {$result == $expected_Result} {
                set result ""
            } else {
                set result [list INPUT: autoTextFile = $autoTextFile, modDir = $modDir path = $path EXPECTED: $expected_Result RETURNED: $result]
            }
        } 
        catch {file rename $path/TEMP$modDir $path/$modDir}
        return $result
    }
    -result {}
    -cleanup {dropAll dbCompare}
}
# DVT - 634357 RE AT test for getObjectTypes
test tcl_unit_getObjectTypes {Unit test for getObjectTypes proc} {
    -setup {}
    -body {

        set rval ""

        unsetInfo dbCompare.OBJECT_TYPES

        # Scenario 1: Happy Flow (what if getInfo dbCompare.OBJECT_TYPE has values)
        set result [getObjectTypes $type]
        if {$result != $list} {
            lappend rval "Scenario 1\n EXPECTED: $list\nRETURNED: $result"
        }

        # Scenario 2: When invalid type is passed
        unset result
        if [catch {set result [getObjectTypes $invalidType]} err] {
        }
        if {$err != $objTypeException} {
            lappend rval "Scenario 2\n EXPECTED: $objTypeException\nRETURNED: $err"
        }

        # Scenario 3: When type is passed as blank
        set result [getObjectTypes $type1]
        if {$result != $list} {
            # return "Scenario 3 - Actual value is: $list\nBut expected value was: $result"
            lappend rval "Scenario 3\n EXPECTED: $list\nRETURNED: $result"
        }

        # Scenario 4: When type is passed as "*"
        set result [getObjectTypes $type2]
        if {$result != $list} {
            lappend rval "Scenario 4\n EXPECTED: $list\nRETURNED: $result"
        }

        # Scenario 5: When type is passed as "USER_CONSTRAINTS"

        set result [getObjectTypes $type3]
        if {$result != $list1} {
            lappend rval "Scenario 5\nEXPECTED: $list1\nRETURNED: $result"
        }

        # Scenario 6: what if added types has values

        setInfo dbCompare.ADD_TYPES "USER_VIEWS"
        set result [getObjectTypes $type]
        if {$result == $list} {
            lappend rval "Scenario 6\nEXPECTED: $list\nRETURNED: $result"
        }
        # Scenario 7: what if Ingore_list is populated

        setInfo dbCompare.IGNORE_LIST "USER_VIEWS"
        set result [getObjectTypes $type]
        if {$result != $list} {
            lappend rval "Scenario 7\nEXPECTED: $list\nRETURNED: $result"
        }

        # Scenario 8 what if when updateInfo dbCompare.OBJECT_TYPES updates the list
        set allTypes_Updated [getInfo dbCompare.OBJECT_TYPES]
        set result [getObjectTypes $type]

        if {$result == $list2} {
            lappend rval "Scenario 8\nEXPECTED: $list2\nRETURNED: $result"
        }
            return $rval
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}

#DVT:634076
test tcl_unit_dbCompareCorrectUsage {Unit test for proc dbCompareCorrectUsage with invalid parameters} {
    -setup {}
    -body {
        catch {exec tclsh dbCompare.tcl Mod3100} output
            if {[regexp $outstatement $output] } {
              return 0
            } else {
              return 1
            }
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}

# DVT - 634356 RE AT test for getModelTypes
test tcl_unit_getModelTypes {Unit test for getModelTypes proc} {
    -setup {}
    -body {
        set rval ""
        set result [getModelTypes $modFileDir]

        if {$result != $list} {
        lappend rval "EXPECTED: $list\nRETURNED: $result"
        }
        if {$rval != ""} {
            return $rval
        }
        return 0
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}

#DVT - 634623
test tcl_unit_hms {Unit test for hms proc in common utilities} {
    -setup {}
    -body {
         set result ""
         set uc $hms_scenarioCount
          if {$hms_names != "negative"} {
            for {set i 1} {$i <= $uc} {incr i} {
              set inpVar [set duration$i]
              set outVar [set hms_out$i]
              set res [hms $inpVar]
              if { $res != $outVar} {
                  lappend result [list Sequence: $i INPUT: $inpVar EXPECTED: $outVar RETURNED: $res]
              }
            }
          } else {
            for {set i 1} {$i <= $uc} {incr i} {
              set inpVar [set duration$i]
              set outVar [set hms_out$i]
              catch {set res [hms $inpVar]} res
              if { [regexp $outVar $res]} {
              } else {
                  lappend result [list Sequence: $i INPUT: $inpVar EXPECTED: $outVar RETURNED: $res]
              }
            }
          }
          if {$result == ""} {
            return 0
          } else {
             return $result
          }
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}

#DVT - 634058
test tcl_unit_prettyTime {Unit test for prettyTime proc in common utilities} {
    -setup {}
    -body {
         set result ""
         set uc $prettyTime_scenarioCount
          if {$prettyTime_names != "negative"} {
            for {set i 1} {$i <= $uc} {incr i} {
              set inpVar [set hms$i]
              set outVar [set prettyTime_out$i]
              set res [prettyTime $inpVar]
              if { $res != $outVar} {
                  lappend result [list Sequence: $i INPUT: $inpVar EXPECTED: $outVar RETURNED: $res]
              }
            }
          } else {
            for {set i 1} {$i <= $uc} {incr i} {
              set inpVar [set hms$i]
              set outVar [set prettyTime_out$i]
              catch {set res [prettyTime $inpVar]} error
              if { [regexp $outVar $error]} {
              } else {
                  lappend result [list Sequence: $i INPUT: $inpVar EXPECTED: $outVar RETURNED: $res]
              }
            }
          }
          if {$result == ""} {
            return 0
          } else {
             return $result
          }
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
# DVT - 634090 RE AT test for getDriverFile
test tcl_unit_getDriverFile {Unit test for getDriverFile proc} {
    -setup {}
    -body {

        set rval ""

        if {$getDriverFile != "negative"} {
            set result [getDriverFile $workingdir]
            if {$result != $DriverFile} {
                lappend rval "Scenario 1 Case Type: $getDriverFile\nExpected: $DriverFile\nActual: $result"
            }
        } else {
            catch {set result [getDriverFile $incorrectworkingdir]} err] {
            puts "err: $err"
            }
            if {$result == $DriverFile} {
            lappend rval "Scenario 2 Case Type: $getDriverFile\nExpected: $DriverFile\nActual: $result"
            }
        }
        return $rval
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
#DVT: 634360
test tcl_unit_getProductName {Unit test for getProductName proc} {
    -setup {}
    -body {
        set rval 0

        for {set i 1} {$i <= 6} {incr i} {
            set prdPrefix [set prdPrefix$i]
            set expected_Result [set expected_Result$i]

            set result [getProductName $prdPrefix]
            if {$result != $expected_Result} {
                lappend rval [list Sequence: $i  INPUT: product Prefix is: $prdPrefix EXPECTED: [$expected_Result RETURNED: $result]
            }
        }
        return $rval
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT: 634072
test tcl_unit_correctArgs {Unit test for correctArgs proc} {
    -setup {}
    -body {

        set result1 ""
        set result2 ""
        set error ""

        #Calling proc correctArgs
        set reval 0
        if [catch {[correctArgs $argc1 $argv1]} error] {
            if {!($error == $output1)} {
                lappend reval [list INPUT: argc = $var1, argv = $var2 EXPECTED: No Error RETURNED: Error - $error]
            }
        }
        #Calling proc correctArgs
        set result1 [correctArgs $argc2 $argv2]
        if {!($result1 == $output2)} {
            lappend reval [list INPUT: argc = $var1, argv = $var2 EXPECTED: $output2 RETURNED: $result1]
        }
        #Calling proc correctArgs
        set result2 [correctArgs $argc3 $argv3]
        if {!($result2 == $output2)} {
            lappend reval [list INPUT: argc = $var1, argv = $var2 EXPECTED: $output2 RETURNED: $result2]
        }
        return $reval

    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT: 633966
test tcl_unit_checkAddSequences {Unit test for checkAddSequences proc} {
    -setup {}
    -body {

        source $sampleDataFile
        set retval ""

        catch {[checkAddSequences model_checkseq target_checkseq] err}
        if {$err < 0} {lappend retval "ERROR while executing checkAddSequences: $err"}

        if {[info exists RESULTS(ADD.SEQUENCES)]} {
            set result [getResults ADD.SEQUENCES]
        }

        if {$result != $returnValue} {
            lappend retval [list INPUT: List is [array get model_checkseq] [array get target_checkseq] EXPECTED: $returnValue RETURNED: $result]
        }

        return $retval

    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
#DVT: 633431
test tcl_unit_compareTables {Unit test for compareTables proc} {
    -setup {}
    -body {
        set results ""
        updateInfo MODEL_FILES_DIRECTORY $MODEL_FILES_DIRECTORY
        setDefaultArray modelDef targetDef $modelConnection $targetConnection
        if {$compareTables_Info == "positive"} {
            for {set i 1} {$i <= 2} {incr i} {
                set modelHeader [set model_header$i]
                set targetHeader [set target_header$i]
                set modelKey [set model_key$i]
                set targetKey [set target_key$i]
                set addDelete_table [set addDelete$i]
                set expectedResult [set expected_Result$i]
                # set number_of_change [set number_of_changes$i]
                set modelDef(USER_TABLES.header) $modelHeader
                set targetDef(USER_TABLES.header) $targetHeader
                set modelDef(USER_TABLES.key) $modelKey
                set targetDef(USER_TABLES.key) $targetKey
                # Calling proc comparetables and it will add results in ARRAY RESULTS
                compareTables targetDef modelDef
                if {$RESULTS($addDelete_table) != $expectedResult} {
                    lappend results [list Sequence: $i  INPUT: modelHeaderis: $modelHeader targetHeader is : $targetHeader modelKey is : $modelKey targetKey is : $targetKey EXPECTED: addDelete Tables: $expectedResult RETURNED: addDelete Tables: $RESULTS($addDelete_table)]
                }
                set RESULTS($addDelete_table) ""
            }
        } else {
            set i 1
            set modelDef(USER_TABLES.header) $model_header
            set targetDef(USER_TABLES.header) $target_header
            set modelDef(USER_TABLES.key) $model_key
            set targetDef(USER_TABLES.key) $target_key
            # Calling proc comparetables and it will add results in ARRAY RESULTS
            compareTables targetDef modelDef
            #Result will be 0 if there is no data in ARRAY RESULTS
            set result [array size RESULTS]
                if {$result != $expected_Result} {
                    lappend results [list Sequence: $i  INPUT: modelHeaderis: $model_header targetHeader is : $target_header modelKey is : $model_key targetKey is : $target_key EXPECTED: $expected_Result RETURNED: addDelete Tables: $result]
                    incr i
                }
        }
            if {$results == ""} {
                return 0
            } else {
                return $results
            }

    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT:634067
test tcl_unit_compareConstraints {Unit test for proc compareConstraints} {
    -setup {}
    -body {
        source $sampleDataFile
        set err ""
        # 1. ADD.CONSTRAINTS - modelDef has more constraint definitions than targetDef
        # 2. DROP.CONSTRAINTS - modelDef has fewer constraint definitions than targetDef
        # 3. ENABLE.CONSTRAINTS & VALIDATE.CONSTRAINTS - modelDef has different constraint definitions than targetDef, in terms of data
        # 4. Same CONSTRAINTS - modelDef has the same constraint definitions as targetDef

        for {set i 1} {$i <= $totalCases} {incr i} {
            setNullResults
            set modelDef [set sampleModelArray$i]
            set targetDef [set sampleTargetArray$i]
            set resultDef [set sampleResults$i]
            compareConstraints $modelDef $targetDef
            if {([getResults ADD.CONSTRAINTS] != [lindex [array get $resultDef ADD.CONSTRAINTS] 1]) || ([getResults DROP.CONSTRAINTS] != [lindex [array get $resultDef DROP.CONSTRAINTS] 1]) || ([getWarnings ENABLE/VALIDATE.CONSTRAINTS] != [lindex [array get $resultDef ENABLE/VALIDATE.CONSTRAINTS] 1]) } {
                lappend err "EXPECTED: ADD.CONSTRAINTS-[lindex [array get $resultDef ADD.CONSTRAINTS] 1] DROP.CONSTRAINTS-[lindex [array get $resultDef DROP.CONSTRAINTS] 1] ENABLE/VALIDATE.CONSTRAINTS-[lindex [array get $resultDef ENABLE/VALIDATE.CONSTRAINTS] 1]\n RETURNED: ADD.CONSTRAINTS-[getResults ADD.CONSTRAINTS] DROP.CONSTRAINTS-[getResults DROP.CONSTRAINTS] ENABLE/VALIDATE.CONSTRAINTS-[getWarnings ENABLE/VALIDATE.CONSTRAINTS]"
            }
            unset RESULTS
        }
        return $err
    }
    -result {}
    -cleanup {dropAll dbCompare}
}
#DVT:634069
test tcl_unit_compareProcedures {Unit test for proc compareProcedures} {
    -setup {}
    -body {
        source $sampleDataFile
        set err ""
        # 1. ADD.CONSTRAINTS - modelDef has more proc definitions than targetDef
        # 2. DROP.PROCEDURES - modelDef has fewer proc definitions than targetDef
        # 3. RECREATE.PROCEDURES - modelDef has different proc definitions than targetDef, but for the same headers
        # 4. Same PROCEDURES def - modelDef has the same proc definitions as targetDef

        for {set i 1} {$i <= $totalCases} {incr i} {
            set modelDef [set sampleModelArray$i]
            set targetDef [set sampleTargetArray$i]
            set resultsDef [set sampleResults$i]
            setNullResults
            compareProcedures $modelDef $targetDef
            if {([getResults ADD.PROCEDURES] != [lindex [array get $resultsDef ADD.PROCEDURES] 1]) || ([getResults DROP.PROCEDURES] != [lindex [array get $resultsDef DROP.PROCEDURES] 1]) || ([getResults RECREATE.PROCEDURES] != [lindex [array get $resultsDef RECREATE.PROCEDURES] 1])} {
                lappend err "EXPECTED: ADD.PROCEDURES-[lindex [array get $resultsDef ADD.PROCEDURES] 1] DROP.PROCEDURES-[lindex [array get $resultsDef DROP.PROCEDURES] 1] RECREATE.PROCEDURES-[lindex [array get $resultsDef RECREATE.PROCEDURES] 1]  RETURNED:  ADD.PROCEDURES-[getResults ADD.PROCEDURES] DROP.PROCEDURES-[getResults DROP.PROCEDURES] RECREATE.PROCEDURES-[getResults RECREATE.PROCEDURES]"
            }
            unset modelDef targetDef RESULTS
        }
        return $err
    }
    -result {}
    -cleanup {dropAll dbCompare}
}

#DVT 634066
test tcl_unit_compareColBits {This UT is for the proc compareColBits.} {
    -setup {}
    -body {
          set result ""
          if {$compareColBits_names != "negative"} {
            set tc $compareColBits_testcount
            for {set i 1} {$i <= $tc} {incr i} {
              set inpVar1 [set mtypes$i]
              set inpVar2 [set targetTypes$i]
              set inpVar3 [set modelCol$i]
              set inpVar4 [set targetCol$i]
              set outVar [set compareColBits_out$i]
              set res [compareColBits $inpVar1 $inpVar2 $inpVar3 $inpVar4]
              if { $res != $outVar} {
                  lappend result [list Sequence: $i INPUT: $inpVar1 $inpVar2 $inpVar3 $inpVar4] EXPECTED: $outVar RETURNED: $res]
              }
            }
          }
          if {$result == ""} {
            return 0
          } else {
             return $result
          }

    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT: 634064
test tcl_unit_updateInfo {Unit test for updateInfo proc} {
    -setup {}
    -body {
        set rval ""

        if {$update_info != "negative"} {
            set result ""
            #Calling proc setinfo to set the value in global Array DBS_INFO
            if [catch {set val [setInfo $name $value]} err] {
                return $err
            }
            #Calling proc updateinfo to update the value in global Array DBS_INFO
            if [catch {set er [updateInfo $name $updated_value]} err] {
                return $err
            }
            if {$DBS_INFO($name) != $expected_Result} {
                lappend rval "Scenario:1\nEXPECTED: $expected_Result\nRETURNED: $DBS_INFO($name)"
            }
        }   else {
                set result ""
                #Calling proc updateinfo to update the value from global Array DBS_INFO
                if [catch {set result [updateInfo $name $updated_value]} err] {
                    return $err
                }
                if {$result != $expected_Result} {
                    lappend rval "Scenario:2\nEXPECTED: $expected_Result\nRETURNED: $result"
                }
            }
        return $rval
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}

#DVT 634073
test tcl_unit_date_now {This UT is for the proc date_now.} {
    -setup {}
    -body {
          set rval ""

          set result [date_now]
          set today [clock format [clock seconds] -format "%m/%d/%Y"]
          if {$result != $today} {
              lappend rval "Sequence: 1\nEXPECTED: $today\nRETURNED: $result"
          }
        return $rval
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}

#DVT 634074
test tcl_unit_dbCompare.unsetAll {This UT is for the proc dbCompare.unsetAll.} {
    -setup {}
    -body {
        set outputFileHandle [open $TCL_UNIT_TEST_WORKING_DIR/testOut.txt w]
          set rval ""
          source $sampleFile
          updateInfo MODEL_FILES_DIRECTORY $MODEL_FILES_DIRECTORY
          setDefaultArray modelDef targetDef $modelConnection $targetConnection
          array set RESULTS [array get USER_TABLES_MODELFILES]
          setInfo dbCompare.REPORT $sampleReport
          set dir         [file dir $sampleReport]
          setInfo dbCompare.OUTDIR "$dir"
          setInfo dbCompare.CORRECTION_SCRIPT_NAME $correctionScriptName

          set dbComparereportfile [getInfo dbCompare.REPORT]
          set dbCompareOUTDIR [getInfo dbCompare.OUTDIR]
          set dbCompareCorrectionScriptName [getInfo dbCompare.CORRECTION_SCRIPT_NAME]

          catch {puts $outputFileHandle "Before unsetAll ModelDef: $modelDef(ModDir)"} err1
          puts $outputFileHandle "Error1: $err1"
          set modelDefDir1 $modelDef(ModDir)

          catch {puts $outputFileHandle "Before unsetAll Target Def: $targetDef(ModDir)"} err2
          puts $outputFileHandle "Error2: $err2"
          set targetDefDir1 $targetDef(ModDir)

          catch {puts $outputFileHandle "Before unsetAll RESULTS: $RESULTS(DEF.USER_TABLES)"} err3
          puts $outputFileHandle "Error3: $err3"
          set resultsDefUserTables1 $RESULTS(DEF.USER_TABLES)

          catch {puts $outputFileHandle "Before unsetAll dbCompare.REPORT: $dbComparereportfile"} err4
          puts $outputFileHandle "Error4: $err4"
          set dbComparereportfile1 $dbComparereportfile

          catch {puts $outputFileHandle "Before unsetAll dbCompare.OUTDIR: $dbCompareOUTDIR"} err5
          puts $outputFileHandle "Error5: $err5"
          set dbCompareOUTDIR1 $dbComparereportfile

          catch {puts $outputFileHandle "Before unsetAll dbCompare.CORRECTION_SCRIPT_NAME: $dbCompareCorrectionScriptName"} err6
          puts $outputFileHandle "Error6: $err6"
          set dbCompareCorrectionScriptName1 $dbCompareCorrectionScriptName

          dbCompare.unsetAll

          catch {puts $outputFileHandle "After unsetAll ModelDef: $modelDef(ModDir)"} err7
          puts $outputFileHandle "Error7: $err7"

          catch {puts $outputFileHandle "After unsetAll Target Def: $targetDef(ModDir)"} err8
          puts $outputFileHandle "Error8: $err8"

          catch {puts $outputFileHandle "After unsetAll RESULTS: $RESULTS(DEF.USER_TABLES)"} err9
          puts $outputFileHandle "Error9: $err9"

          set dbComparereportfile2 [getInfo dbCompare.REPORT]
          set dbCompareOUTDIR2 [getInfo dbCompare.OUTDIR]
          set dbCompareCorrectionScriptName2 [getInfo dbCompare.CORRECTION_SCRIPT_NAME]

          catch {puts $outputFileHandle "After unsetAll dbCompare.REPORT: $dbComparereportfile"} err10
          puts $outputFileHandle "Error10: $err10"

          catch {puts $outputFileHandle "After unsetAll dbCompare.OUTDIR: $dbCompareOUTDIR"} err11
          puts $outputFileHandle "Error11: $err11"

          catch {puts $outputFileHandle "After unsetAll dbCompare.CORRECTION_SCRIPT_NAME: $dbCompareCorrectionScriptName"} err12
          puts $outputFileHandle "Error12: $err12"

          set Error7 "can\'t read \"modelDef\(ModDir\)\": no such variable"
          set Error8 "can\'t read \"targetDef\(ModDir\)\": no such variable"
          set Error9 "can\'t read \"RESULTS\(DEF.USER_TABLES\)\": no such variable"

          if { ($modelDefDir1 == "") &&
               ($targetDefDir1 == "") &&
               ($resultsDefUserTables1 == "") &&
               ($dbComparereportfile1 == "") &&
               ($dbCompareOUTDIR1 == "") &&
               ($dbCompareCorrectionScriptName1 == "") &&
               ($err7 != $Error7) &&
               ($err8 != $Error8) &&
               ($err9 != $Error9) &&
               ($dbComparereportfile2 != "") &&
               ($dbCompareOUTDIR2 != "") &&
               ($dbCompareCorrectionScriptName2 != "") } {
               lappend rval "EXPECTED 1: $modelDefDir1\nRETURNED 1: \nEXPECTED 2: $targetDefDir1\nRETURNED 2: \nEXPECTED 3: $resultsDefUserTables1\nRETURNED 3: \nEXPECTED 4: $dbComparereportfile1\nRETURNED 4: \nEXPECTED 5: $dbCompareOUTDIR1\nRETURNED 5: \nEXPECTED ERR7: $err7\nRETURNED ERR7: $Error7\nEXPECTED ERR8: $err8\nRETURNED ERR8: $Error8\nEXPECTED ERR9: $err9\nRETURNED ERR9: $Error9\nEXPECTED 6: $dbComparereportfile2\nRETURNED 6: \nEXPECTED 7: $dbCompareOUTDIR2\nRETURNED 7: \nEXPECTED 8: $dbCompareCorrectionScriptName2\nRETURNED 8: "
          }
        close $outputFileHandle
        return $rval
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
#DVT: 633967
test tcl_unit_checkDropSequences {Unit test for checkDropSequences proc} {
    -setup {}
    -body {

        source $sampleDatacheckDrop
        set retval ""

        catch {[checkDropSequences model_checkseqDrop target_checkseqDrop] err}
        if {$err < 0} {lappend retval "ERROR while executing checkDropSequences: $err"}

        catch {[set returnValue [getResults DROP.SEQUENCES]] err}
        if {$err < 0} {lappend retval "ERROR key DROP.SEQUENCES not found: $err"}

        if {$result != $returnValue} {
           lappend retval [list INPUT: List is [array get model_checkseqDrop] [array get target_checkseqDrop] EXPECTED: $returnValue RETURNED: $result]
        }

        return $retval
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
#DVT: 634085
test tcl_unit_getClientTables {Unit test for getClientTables proc} {
    -setup {}
    -body {
        set results ""
        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            set source_file [set source_where_file$i]
            set expectedResult [set expected_Result$i]
            #Calling proc getClientTables to get the ClientTables
            if { [catch {set result [getClientTables $source_file]} err] } {
                return $err
            }
            if {$result != $expectedResult} {
                lappend results [list Sequence: $i  INPUT: Source File: $source_file EXPECTED: $expectedResult RETURNED: $result]
            }
        }
        if {$results == ""} {
            return 0
        } else {
            return $results
        }
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT:629362
test tcl_unit_getValuesFor {Unit test for proc getValuesFor} {
    -setup {}
    -body {
        source $sampleDataFile
        global modelDef
        set err ""
        for {set counter 0} {$counter < $countOfScenarios} {incr counter} {
            set val ""
            set inputList [set "inputList$counter"]
            set resultList [set "sampleResults$counter"]
            catch {set val [getValuesFor ${inputList}]}
            if {$val != ${resultList}} {
            lappend err "INPUT: ${inputList} EXPECTED: ${resultList} RETURNED: $val"}
        }
        return $err
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
#DVT: 634077
test tcl_unit_delete_like {Unit test for delete_like proc} {
    -setup {}
    -body {
       file delete -force $TCL_UNIT_TEST_WORKING_DIR/$testdir
       file mkdir $TCL_UNIT_TEST_WORKING_DIR/$testdir
       set rval ""
       set error ""
       foreach pt $pattern {
            foreach file $filenamelist {
                set fid [open "$TCL_UNIT_TEST_WORKING_DIR/$testdir/$file" w]
                puts $fid "testing...."
                close $fid
            }
            set fileBeforeDeletion [glob -nocomplain $TCL_UNIT_TEST_WORKING_DIR/$testdir/$pt]
            set result [delete_like $TCL_UNIT_TEST_WORKING_DIR/$testdir/$pt]
            set filesAfterDeletion [glob -nocomplain $TCL_UNIT_TEST_WORKING_DIR/$testdir/$pt]
            if {$result != 0 || [llength $filesAfterDeletion] != 0}  {
               append rval "pattern = $pt result = $result after = $filesAfterDeletion"
            }
        }
        set fid [open "$TCL_UNIT_TEST_WORKING_DIR/$testdir/$negativefilename" w]
        if [catch {[delete_like $TCL_UNIT_TEST_WORKING_DIR/$testdir/$negativepattern]} error] {
        puts $error
            if {$error != $negativeResult} {
                set filesAfterDeletion [glob -nocomplain $testdir/$negativepattern]
                append rval "pattern = $negativepattern , error = $negativeResult , files = $filesAfterDeletion\n"
            }
        }
        close $fid
        foreach file $negativefilename1 {
            set fid [open "$TCL_UNIT_TEST_WORKING_DIR/$testdir/$file" w]
            puts $fid "testing...."
            close $fid
        }
        if [catch {[delete_like $TCL_UNIT_TEST_WORKING_DIR/$testdir/$negativepattern1]} error] {
            if {$error != $negativeResult1} {
                set filesAfterDeletion [glob -nocomplain $TCL_UNIT_TEST_WORKING_DIR/$testdir/$negativepattern1]
                append rval "pattern = $negativepattern , error = $negativeResult1 , files = $filesAfterDeletion\n"
            }
        }
        if { $rval == "" } {
            set rval 0
        }
        return $rval
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT: 634088
test tcl_unit_getConversionInfo {Unit test for getConversionInfo proc} {
    -setup {}
    -body {
        set results ""
        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            set startLine [set startLine$i]
            set priorVersion [set priorVersion$i]
            set currentVersion [set currentVersion$i]
            set testVersion [set testVersion$i]
            set fid [open $TCL_UNIT_TEST_WORKING_DIR/$driverFile w]
            puts $fid "$startLine"
            puts $fid "2 $currentProduct[join [p_pad_version $priorVersion] ""].sql [join [p_pad_version $priorVersion] "."] $currentProduct Mod[join [p_unpad_version $priorVersion] ""]"
            puts $fid "3 $currentProduct[join [p_pad_version $currentVersion] ""].sql [join [p_pad_version $currentVersion] "."] $currentProduct Mod[join [p_unpad_version $currentVersion] ""]"
            close $fid
            set expectedResult [set expected_Result$i]
            #Calling proc getConversionInfo to get the lines
            if [catch {set result [getConversionInfo $TCL_UNIT_TEST_WORKING_DIR/$driverFile $currentProduct $testVersion]} err] {
                return $err
            }
            if {$result!= $expectedResult} {
                lappend results [list Sequence: $i  INPUT: Driver File: $driverFile Current Product: $currentProduct Current Version: $currentVersion EXPECTED: $expectedResult RETURNED: $result]
            }
            catch {file delete $TCL_UNIT_TEST_WORKING_DIR/$driverFile}
        }
        if {$results == ""} {
            return 0
        } else {
            return $results
        }
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}


#DVT:634071
test tcl_unit_compareTriggers {Unit test for proc compareTriggers} {
    -setup {}
    -body {
        source $sampleDataFile
        set err ""
        set matched ""
        if {$xmlVerNum >= 03020000 && $condition == "ge"} {
            for {set i 1} {$i <= $totalCases} {incr i} {
                setNullResults
                set modelDef [set sampleModel$i]
                set targetDef [set sampleTarget$i]
                set resultDef [set sampleResults$i]
                compareTriggers $modelDef $targetDef
                regexp {XLD_XLT_TRANSLATION_DATA} "[getResults RECREATE.TRIGGERS]" matched
                regsub -all {\s} $matched {} final
                if {$resultDef != $final } {
                    lappend err "SEQUENCE: $i EXPECTED: $resultDef RETURNED: $final "
                }
            }

        } else { lappend err "Skipped: $xmlVerNum" }

        return $err
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
#DVT: 634361
test tcl_unit_getReportFile {Unit test for getReportFile proc} {
    -setup {}
    -body {
        set results ""
        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            set out_directory $TCL_UNIT_TEST_WORKING_DIR/[set outdir$i]
            set report_file [set reportfile$i]
            set toolname [set toolname$i]
            if [catch {set expectedError [set expected_error$i]}] {
                set expectedError ""
            }
            # get the Absolute path of outdir
            set out_Dir [file normalize $out_directory]
            if {$out_Dir == ""} {
                set out_Dir [pwd]
                set file_name $report_file
            } else {
                set file_name $out_Dir/$report_file
            }
            #Calling proc getReportFile
            if [catch {set result [getReportFile $toolname $out_directory $report_file]} err] {
                if {$err != "$expectedError $out_Dir"} {
                        lappend results [list Sequence: $i  INPUT: Tool Name: $toolname Report File: $report_file Out Directory: $out_Dir EXPECTED: $expectedError $out_Dir RETURNED: $err]
                 }
                  continue
            }     
            # Check if report file exists in directory
            if [catch { set file_exist [glob "$file_name"]} err] {
                lappend results "Sequence $i $err"
            }
            if {$DBS_INFO($toolname.OUTDIR) != $out_Dir && $DBS_INFO($toolname.REPORT_FILE) != $report_file} {
                lappend results [list Sequence: $i  INPUT: Tool Name: $toolname Report File: $report_file Out Directory: out_Dir EXPECTED: Out Dir: $out_Dir Report file: $report_file RETURNED: Out Dir: $DBS_INFO($toolname.OUTDIR) Report File: $DBS_INFO($toolname.REPORT_FILE)]
            }
        }
            return $results
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
#DVT: 634092
test tcl_unit_getFirstDriverRowInfo {Unit test for getFirstDriverRowInfo proc} {
    -setup {}
    -body {
        set result ""
        set tc $getDriverRowInfo_scenarioCount
        if {$getDriverRowInfo_names != "negative"} {
          for {set i 1} {$i <= $tc} {incr i} {
            set inpVar1 [set targetTokenInput$i]
            set inpVar2 [set itemInput$i]
            set outVar [set getDriverRowInfoOut$i]
            set res [getFirstDriverRowInfo $inpVar1 $inpVar2]
            if { $res != $outVar} {
                lappend result [list Sequence: $i INPUT: targetToken:$inpVar1 itemInput:$inpVar2  EXPECTED: $outVar RETURNED: $res \n]
            }
          }
        }
        if {$result == ""} {
          return 0
        } else {
           return $result
        }
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT: 634079
test tcl_unit_fileJoinX1.1 {Unit test for fileJoinX proc with 3 args} {
    -setup {}
    -body {
        set results ""
        for {set i 1} {$i <= 5} {incr i} {
            set working_dir [set workingdir$i]
            set file_name [set file$i]
            set expectedResult [set expected_Result$i]
            #Calling proc filejoinx with 2 args
            if [catch {set result [filejoinx $working_dir $file_name]} err] {
                return $err
            }
            if {$result != $expectedResult} {
                lappend results [list Sequence: $i  INPUT: Working Dir: $working_dir File : $file_name EXPECTED: $expectedResult RETURNED: $result]
            }
        }
        if {$results == ""} {
            return 0
        } else {
            return $results
        }
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT: 634079
test tcl_unit_fileJoinX1.2 {Unit test for fileJoinX proc with 3 args} {
    -setup {}
    -body {
        set results ""
        for {set i 1} {$i <= 3} {incr i} {
            set working_dir [set workingdir$i]
            set file_name [set file$i]
            set path_name [set path$i]
            set expectedResult [set expected_Result$i]
            #Calling proc filejoinx with 3 args
            if [catch {set result [filejoinx $working_dir $path_name $file_name]} err] {
                return $err
            }
            if {$result != $expectedResult} {
                lappend results [list Sequence: $i  INPUT: Working Dir: $working_dir File : $file_name EXPECTED: $expectedResult RETURNED: $result]
            }
        }
        if {$results == ""} {
            return 0
        } else {
            return $results
        }
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT: 634062
test tcl_unit_srange_1.1 {Unit test for srange proc} {
    -setup {}
    -body {

        set retval ""
        set result ""
        # If schema not present in the schema List get it from schema pool
        set finalresult1 [lindex [split $logonstring /] 0]
        for {set i 1} {$i <= $no_of_scenarios} {incr i} {

            set inpVar1 [set testsection$i]
            set inpVar2 [set testtoken$i]
            set inpVar3 [set testsection$i]
            set outVar [set finalresult$i]

            set result [srange $inpVar1 $inpVar2 $logonstring]

            if {$result != $outVar}  {
               lappend retval [list Sequence: $i INPUT: List is: $inpVar1 $inpVar2 $logonstring EXPECTED: $outVar RETURNED: $result]
            }

            return $retval
        }
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
#DVT: 634062
test tcl_unit_srange_1.2 {Unit test for srange proc} {
    -setup {}
    -body {

            set retval ""

            set version [srange between "_" $productversion "nocomplain"]

            if {$version != $outputversion}  {
                lappend retval [list INPUT: List is {between "_" $productversion "nocomplain"} EXPECTED: $outputversion RETURNED: $version]
            }

            return $retval

    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
#DVT: 634359
test tcl_unit_getPrevDriverRow {Unit test for getPrevDriverRow proc} {
    -setup {}
    -body {
        set results ""
        set result ""
        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            set driver_File [set driverFile$i]
            set current_Script [set currentScript$i]
            set expectedResult [set expected_Result$i]
            #Calling proc getPrevDriverRow
            if [catch {set result [getPrevDriverRow $driver_File $current_Script]} err] {
                if {$err == $expectedResult} {
                    # expecting error for one scenario
                    continue
                } else {
                    lappend results [list Sequence: $i  INPUT: Driver File: driver_File Current Script: $current_Script EXPECTED: $expectedResult RETURNED: $err]
                }
            }
            if {$result != $expectedResult} {
                lappend results [list Sequence: $i  INPUT: Driver File: $driver_File Current Script: $current_Script EXPECTED: $expectedResult RETURNED: $result]
            }
        }
            return $results
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
#DVT: 634080
test tcl_unit_findListItemAll {Unit test for findListItemAll proc} {
    -setup {}
    -body {
        set results ""
        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            set list_Name [set listName$i]
            set search_Item [set searchItem$i]
            set expectedResult [set expected_Result$i]
            #Calling proc findListItemAll and passing list name
            if [catch {set result [findListItemAll $list_Name $search_Item]} err] {
                return $err
            }
            #Calling proc findListItemAll and passing list values
            if [catch {set result1 [findListItemAll $list_Name $search_Item]} err] {
                return $err
            }
            if {$result != $expectedResult || $result1 != $expectedResult} {
                lappend results [list Sequence: $i  INPUT: List is: $list_Name search Item is : $search_Item EXPECTED: $expectedResult RETURNED: $result and $result1]
            }
        }
        if {$results == ""} {
            return 0
        } else {
            return $results
        }
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT: 634364
test tcl_unit_getSchemaSequences {Unit test for getSchemaSequences} {
    -setup {}
    -body {
        set results ""
        # set the values in modelDef array
        updateInfo MODEL_FILES_DIRECTORY $MODEL_FILES_DIRECTORY
        setDefaultArray modelDef targetDef $modelConnection $targetConnection
        # If schema not present in the schema List get it from schema pool
        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            set tabPrefix [set  tab_prefix$i]
            set expectedList [set expected_List$i]
            #Calling proc getSchemaSequences to get schema sequence
            if [catch {set result [getSchemaSequences $targetConnection modelDef $tabPrefix]} err] {
                return $err
            }
            if {$result != $expectedList} {
                lappend results [list Sequence: $i  INPUT: Database Handler: $targetConnection Tab Prifix: $tabPrefix EXPECTED: $expectedList RETURNED: $result]
            }
        }
            return $results
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
#DVT: 634080
test tcl_unit_findListItem {Unit test for findListItem proc} {
    -setup {}
    -body {
        set results ""
        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            set list_Name [set listName$i]
            set search_Item [set searchItem$i]
            set expectedResult [set expected_Result$i]
            #Calling proc findListItem and passing list name
            if [catch {set result [findListItem $list_Name $search_Item]} err] {
                return $err
            }
            #Calling proc findListItem and passing list values
            if [catch {set result1 [findListItem $list_Name $search_Item]} err] {
                return $err
            }
            if {$result != $expectedResult || $result1 != $expectedResult} {
                lappend results [list Sequence: $i  INPUT: List is: $list_Name search Item is : $search_Item EXPECTED: $expectedResult RETURNED: $result and $result1]
            }
        }
        if {$results == ""} {
            return 0
        } else {
            return $results
        }
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
# DVT:634068
test tcl_unit_compareIndexes {Unit test for proc compareIndexes} {
    -setup {}
    -body {
        source $sampleDataFile
        set err ""
        # Scenario 1 : INDEX definition different in target and model
        # Scenario 2 : Blank INDEX defs in targetDef
        # Scenario 3 : Blank INDEX defs in modelDef
        # Scenario 4 : modelDef has more INDEX defs than targetDef for the same table
        # Scenario 5 : modelDef has fewer INDEX defs than targetDef for the same table
        # Scenario 6 : modelDef has the same INDEX defs as targetDef
        # Scenario 7 : rename should be called in case of same defination but different index name
        # Scenario 8 : modelDef has the different posion of the same column list for the index
        # Scenario 9 : modelDef has the different posion of the same column list with different name of the index

        for {set i 1} {$i <= $totalCases} {incr i} {
            setNullResults
            set modelDef [set sampleModel$i]
            set targetDef [set sampleTarget$i]
            set resultDef [set sampleResults$i]
            compareIndexes $modelDef $targetDef
            if {([getResults RENAME.INDEXS] != [lindex [array get $resultDef RENAME.INDEXS] 1]) || ([getResults ADD.INDEXS] != [lindex [array get $resultDef ADD.INDEXS] 1]) || ([getWarnings REVIEW.CUSTOM_INDEXS] != [lindex [array get $resultDef REVIEW.CUSTOM_INDEXS] 1]) || ([getResults RECREATE.INDEXS] != [lindex [array get $resultDef RECREATE.INDEXS] 1]) || ([getResults number_of_changes] != [lindex [array get $resultDef number_of_changes] 1])} {
                lappend err "Sequence : sampleResults$i  EXPECTED: RENAME.INDEXS-[lindex [array get $resultDef RENAME.INDEXS] 1] ADD.INDEXS-[lindex [array get $resultDef ADD.INDEXS] 1]  REVIEW.CUSTOM_INDEXS-[lindex [array get $resultDef REVIEW.CUSTOM_INDEXS] 1]  RECREATE.INDEXS-[lindex [array get $resultDef RECREATE.INDEXS] 1] number_of_changes-[lindex [array get $resultDef number_of_changes] 1]  RETURNED: RENAME.INDEXS-[getResults RENAME.INDEXS] ADD.INDEXS-[getResults ADD.INDEXS] REVIEW.CUSTOM_INDEXS-[getWarnings REVIEW.CUSTOM_INDEXS] RECREATE.INDEXS-[getResults RECREATE.INDEXS] number_of_changes-[getResults number_of_changes]"
            }
            unset RESULTS
        }
        return $err
    }
    -result {}
    -cleanup {dropAll dbCompare}
}
#DVT: 634083
test tcl_unit_findSpoolFile {Unit test for findSpoolFile proc} {
    -setup {}
    -body {
        set result1 ""
        set result2 ""
        set rval 0
        if {$type == "positive"} {
            set directory $TCL_UNIT_TEST_WORKING_DIR
        } else {
            set folderName "name with space"
            set directory "$TCL_UNIT_TEST_WORKING_DIR/$folderName"
            catch [file delete -force $directory] err
            file mkdir $directory
        }
        set fid [open "$directory/$scriptName\_$ext" w]
        puts $fid "testing...."
        close $fid

        set result1 [findSpoolFile $scriptName $directory $ext]
        regsub "$scriptName\_$ext $result1" {} result1
        set expectedResult "$directory/$scriptName\_$ext"

        if {$result1 != $expectedResult} {
            set rval "output1 file is not found at $directory result1= $result1 expectedResult=$expectedResult"
        }

        catch {[findSpoolFile $scriptName $directory]} result2
        if {$result2 == ""} {
            set rval "output2 file is not found at $directory"
        }
        file delete "$scriptName\_$ext"
        return $rval
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT: 634059
test tcl_unit_selectFromFile1.1 {Unit test for selectFromFile proc} {
    -setup {}
    -body {

        set retval ""
        set result ""
        set tabPrefix [string range $RconstraintName 0 2]

        updateInfo MODEL_FILES_DIRECTORY $MODEL_FILES_DIRECTORY
        setDefaultArray modelDef targetDef $modelConnection $targetConnection

        #Calling proc selectFromFile
        set result [selectFromFile modelDef USER_CONS_COLUMNS $tabPrefix $RconstraintName]

            if {$result != $list1} {
                lappend retval [TEST_TYPE: $type INPUT: List is [array get modelDef] {USER_CONS_COLUMNS $tabPrefix $RconstraintName} EXPECTED: $list1 RETURNED: $result]
            }

        return $retval
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
# DVT 634059
test tcl_unit_selectFromFile1.2 {Unit test for selectFromFile proc} {
    -setup {}
    -body {

        set retval ""
        set result ""
        updateInfo MODEL_FILES_DIRECTORY $MODEL_FILES_DIRECTORY
        setDefaultArray modelDef targetDef $modelConnection $targetConnection

        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            set key [set key$i]
            set targetDef(ModDir) $key
            set inpVar1 [set objectname$i]
            set inpVar2 [set RconstraintName$i]
            set tabPrefix [string range $inpVar2 0 2]
            set outVar  [set list$i]
            catch {set result [selectFromFile targetDef $inpVar1  $tabPrefix $inpVar2]} out

            if {$out != $outVar} {
                lappend retval [list TYPE: $type INPUT: List is [array get modelDef] $inpVar1 $tabPrefix $inpVar2 EXPECTED: $outVar RETURNED: $out]
            }
        }
        return $retval

    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
#DVT: 634096
test tcl_unit_getModDirsFrom {Unit test for getModDirsFrom proc} {
    -setup {}
    -body {
        set result1 ""
        set result2 ""

        set result1 [getModDirsFrom $driverFile $sourceModDir $targetModDir1]
        set result2 [getModDirsFrom $driverFile $sourceModDir $targetModDir2]

        if {($result1 == $result2) || ($result1 == $expected_result)} {
            return 0
        } else {
            return [list INPUT: sourceModDir=$sourceModDir, targetModDir=$targetModDir1 EXPECTED: $expected_result RETURNED: $result1]
        }
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT: 635381
test tcl_unit_getSchemaVersions {Unit test for getSchemaVersions proc} {
    -setup {}
    -body {
          if { [catch {getLogonHandle $targetConnection} dbh ] }  {
              puts "***ERROR - Cannot log onto $targetConnection"
              return "Unable to log onto database"
          }

          set result ""
          set uc $getSchemaVersions_ScenarioCount
          if {$getSchemaVersions_names != "negative"} {
            for {set i 1} {$i <= $uc} {incr i} {
              set inpVar [set itemInput$i]
              set outVar [set getSchemaVersionsOut$i]
              set res [getSchemaVersions $dbh $inpVar]
              if { $res != $outVar} {
                  lappend result [list Sequence: $i INPUT: $inpVar EXPECTED: $outVar RETURNED: $res]
              }
            }
          } else {
            #No negative cases added currently in XML
            }

          if {$result == ""} {
            return 0
          } else {
             return $result
          }
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT: 635380
test tcl_unit_getSchemaVersion {Unit test for getSchemaVersion proc} {
    -setup {}
    -body {
          if { [catch {getLogonHandle $targetConnection} dbh ] }  {
              puts "***ERROR - Cannot log onto $targetConnection"
              return "Unable to log onto database"
          }

          set result ""
          set uc $getSchemaVersion_ScenarioCount
          if {$getSchemaVersion_names != "negative"} {
            for {set i 1} {$i <= $uc} {incr i} {
              set inpVar [set itemInput$i]
              set outVar [set getSchemaVersionOut$i]
              set res [getSchemaVersion $dbh $inpVar]
              if { $res != $outVar} {
                  lappend result [list Sequence: $i INPUT: $inpVar EXPECTED: $outVar RETURNED: $res]
              }
            }
          } else {
            #No negative cases added currently in XML
            }

          if {$result == ""} {
            return 0
          } else {
             return $result
          }
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT: 634082
test tcl_unit_findSequenceTarget {Unit test for findSequencesTarget} {
    -setup {}
    -body {
        set results ""
        source $TEST_HOME/testdata/Array_Input_Output.txt
        # set the values in modelDef array
        updateInfo MODEL_FILES_DIRECTORY $MODEL_FILES_DIRECTORY
        setDefaultArray model target $modelConnection $targetConnection
        set model(USER_TAB_COLUMNS.header) $USER_TAB_COLUMNS_header
        set model(USER_TAB_COLUMNS.key) $USER_TAB_COLUMNS_key
        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            set seq_Name [set seqName$i]
            set expectedResult [set expected_Result$i]
            #Calling proc findSequenceTarget to get sequence Target
            if [catch {set result [findSequenceTarget model $seq_Name]} err] {
                return $err
            }
            if {$result != $expectedResult} {
                lappend results [list Sequence: $i  INPUT: Sequence Name: $seq_Name EXPECTED: $expectedResult RETURNED: $result]
            }
        }
        if {$results == ""} {
            return 0
        } else {
            return $results
        }
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT: 635384
test tcl_unit_getSHSinsert {Unit test for getSHSinsert} {
    -setup {}
    -body {
        set results ""
        source $TEST_HOME/testdata/Array_Input_Output.txt
        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            set script_name [set scriptname$i]
            set type_val [set type$i]
            set desc_val [set desc$i]
            set status_val [set status$i]
            set new_version [set newversion$i]
            set old_version [set oldversion$i]
            set insertQuery [set insert_Query$i]
            #Calling proc getSHSinsert to get schema sequence
            if [catch {set result [getSHSinsert $script_name $type_val $desc_val $status_val $new_version $old_version]} err] {
                return $err
            }
            if {$result != $insertQuery} {
                lappend results [list Sequence:$i  Script Name: $script_name Type: $type_val Description: $desc_val Status: $status_val New Version: $new_version Old Version: $old_version EXPECTED: $insertQuery RETURNED: $result]
            }
        }
        return $results
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
#DVT: 634060
test tcl_unit_selectFromSchema {Unit test for selectFromSchema proc} {
    -setup {}
    -body {
        set retval ""
        set result ""
        updateInfo MODEL_FILES_DIRECTORY $MODEL_FILES_DIRECTORY
        setDefaultArray modelDef targetDef $modelConnection $targetConnection

        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            set inpVar1 [set table$i]
            set inpVar2 [set RconstraintName$i]
            set inpVar3 [set type$i]
            set outVar [set list$i]

            if [catch {set result [selectFromSchema targetDef USER_CONS_COLUMNS $inpVar1 $inpVar2]} err] {
                 if {$err == $outVar} {
                 continue }
                 else {
                 lappend retval [list TYPE: $inpVar3 INPUT: List is [array get modelDef] $inpVar1 $inpVar2 EXPECTED: $outVar RETURNED: $result]
                 continue}
            }
            if {$result != $outVar} {
               lappend retval [list TYPE: $inpVar3 INPUT: List is [array get modelDef] $inpVar1 $inpVar2 EXPECTED: $outVar RETURNED: $result]
            }
        }
        return $retval
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
#DVT: 634060
test tcl_unit_selectFromSchema1.2 {Unit test for selectFromSchema proc} {
    -setup {}
    -body {

        updateInfo MODEL_FILES_DIRECTORY $MODEL_FILES_DIRECTORY
        setDefaultArray modelDef targetDef $modelConnection $targetConnection

        catch {set result [selectFromSchema targetDef USER_CONS_COLUMNS $table $RconstraintName]} err

        if {$err != ""} { return 0}
        return $err
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT: 634060
test tcl_unit_selectFromSchema1.3 {Unit test for selectFromSchema proc} {
    -setup {}
    -body {

        updateInfo MODEL_FILES_DIRECTORY $MODEL_FILES_DIRECTORY
        setDefaultArray modelDef targetDef $modelConnection $targetConnection

        catch {set result [selectFromSchema targetDef USER_CONS_COLUMNS $table $RconstraintName]} err

        if {$list1 == $result} {
            return 0
        } else {return $result}
    }
        -result { 0 }
        -cleanup {dropAll dbCompare}

}
#DVT: 634363
test tcl_unit_getSchemaProduct {Unit test for getSchemaProduct proc} {
    -setup {}
    -body {
        set result ""
        if { [catch {getLogonHandle $targetConnection} dbh ] }  {
            lappend result "Unable to log onto database $targetConnection"
        }
        if { [catch {set res [getSchemaProduct $dbh]} err] } {
            lappend result $err $inpVar
        } else {
            if { $res != $schemaProductOut} {
                lappend result "EXPECTED: $schemaProductOut RETURNED: $res"
            }
        }
        if {$result == ""} {
            return 0
        } else {
            return $result
        }
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT: 634358
test tcl_unit_GetOraDefTblSpace {Unit test for GetOraDefTblSpace proc} {
    -setup {}
    -body {
          set rval ""

        if { [catch {getLogonHandle $targetConnection} dbh ] }  {
            puts "***ERROR - Cannot log onto $targetConnection"
            return "Unable to log onto database"
        } else {
            set result [GetOraDefTblSpace $dbh]
        }
        if {$result != $GetOraDefTblSpaceOut} {
            lappend rval "Sequence: $i\nEXPECTED: $GetOraDefTblSpaceOut\nRETURNED: $result"
        }
        return $rval
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
#DVT: 635388
test tcl_unit_getSqlListMID {Unit test for getSqlListMID proc} {
    -setup {}
    -body {
        set result ""

        set result [getSqlListMID]
        if {$result == $expectedResult} {
            return 0
        } else {
            return [list INPUT: "" EXPECTED: $expectedResult RETURNED: $result]
        }
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT: 635389
test tcl_unit_getSqlListDROP {Unit test for getSqlListDROP proc} {
    -setup {}
    -body {
        set result ""

        set result [getSqlListDROP]
        if {$result == $expectedResult} {
            return 0
        } else {
            return [list INPUT: "" EXPECTED: $expectedResult RETURNED: $result]
        }
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT: 634078
test tcl_unit_deleteNonSysSpool {Unit test for deleteNonSysSpool proc} {
    -setup {}
    -body {
        set result ""
        set directory $TCL_UNIT_TEST_WORKING_DIR
        append directory "/deleteNonSysSpool"
        file mkdir $directory
        set fid1 [open "$directory/DeleteNonSysSpool_Deletes_file.txt" w]
        close $fid1
        set fid2 [open "$directory/DeleteNonSysSpool_nonSpool_file.txt" w]
        close $fid2

        set Del_Report_lst1 [glob -directory $directory -nocomplain *_Deletes_*.*]
        deleteNonSysSpool $directory
        set Del_Report_lst2 [glob -directory $directory -nocomplain *_Deletes_*.*]
        set Del_Report_lst3 [glob -directory $directory -nocomplain DeleteNonSysSpool_nonSpool_file.txt]

        file delete -force $directory/DeleteNonSysSpool_Deletes_file.txt
        file delete -force $directory/DeleteNonSysSpool_nonSpool_file.txt


        if {!(([llength $Del_Report_lst1] == 1) && ([llength $Del_Report_lst2] == 0))} {
            lappend result [list INPUT: "" EXPECTED: should delete spool files RETURNED: not deleting spool file]
        }
        if {[llength $Del_Report_lst3] != 1} {
            lappend result [list INPUT: "" EXPECTED: should not delete non-spool files RETURNED: deleting non-spool file]
        }
        catch {file delete -force $directory}
        if {$result == ""} {
            return 0
        } else {
            return $result
        }
    }
    -result { 0 }
}
#DVT: 634070
test tcl_unit_compareTextIndices {Unit test for proc compareTextIndices} {
    -setup {}
    -body {
        source $sampleDataFile
        set err ""
        # Scenario 1 : No. of TEXT_INDEX definitions more in modelDef than in targetDef
        # Scenario 2 : No. of TEXT_INDEX definitions lesser in modelDef than in targetDef
        # Scenario 3 : Blank TEXT_INDEX defs in modelDef
        # Scenario 4 : Blank INDEX defs in targetDef
        # Scenario 5 : modelDef has different keys for TEXT_INDEX defs than targetDef for the same table
        # Scenario 6 : modelDef has different data for TEXT_INDEX defs than targetDef for the same table
        # Scenario 7 : modelDef has the same INDEX defs as targetDef

        for {set i 1} {$i <= $totalCases} {incr i} {
            set modelDef [set sampleModel$i]
            set targetDef [set sampleTarget$i]
            set resultDef [set sampleResults$i]
            setNullResults
            compareTextIndices $modelDef $targetDef
            if {([getResults ADD.TEXT_INDEXS] != [lindex [array get $resultDef ADD.TEXT_INDEXS] 1]) || ([getResults DROP.TEXT_INDEXS] != [lindex [array get $resultDef DROP.TEXT_INDEXS] 1]) || ([getResults RECREATE.TEXT_INDEXS] != [lindex [array get $resultDef RECREATE.TEXT_INDEXS] 1]) || ([getResults number_of_changes] != [lindex [array get $resultDef number_of_changes] 1])} {
                lappend err "SEQUENCE: $i EXPECTED: ADD.TEXT_INDEXS-[lindex [array get $resultDef ADD.TEXT_INDEXS] 1] DROP.TEXT_INDEXS-[lindex [array get $resultDef DROP.TEXT_INDEXS] 1] RECREATE.TEXT_INDEXS-[lindex [array get $resultDef RECREATE.TEXT_INDEXS] 1] number_of_changes-[lindex [array get $resultDef number_of_changes] 1]  RETURNED: ADD.TEXT_INDEXS-[getResults ADD.TEXT_INDEXS]  DROP.TEXT_INDEXS-[getResults DROP.TEXT_INDEXS]  RECREATE.TEXT_INDEXS-[getResults RECREATE.TEXT_INDEXS] number_of_changes-[getResults number_of_changes]"
            }
        }
        return $err
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
#DVT: 634365
test tcl_unit_getSchemaTextIndexData {Unit test for getSchemaTextIndexData} {
    -setup {}
    -body {
        set results ""
        if {$getSchemaTextIndexData_type == "negative"} {
            source $TEST_HOME/testdata/Array_Input_Output.txt
        }
        # set the values in model array
        updateInfo MODEL_FILES_DIRECTORY $MODEL_FILES_DIRECTORY
        setDefaultArray model target $modelConnection $targetConnection

        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            set types [set type$i]
            set table_name [set tables$i]
            set INDEXES_data [set TEXT_INDEXES_data$i]
            set INDEXES_header [set TEXT_INDEXES_header$i]
            set INDEXES_key [set TEXT_INDEXES_key$i]
            #Calling proc getSchemaTextIndexData to get TEXT_INXEDES values in array
            if [catch {set result [getSchemaTextIndexData model $targetConnection $types $table_name]} err] {
                return $err
            }
            if {$model(TEXT_INDEXES.data) != $INDEXES_data || $model(TEXT_INDEXES.header) != $INDEXES_header || $model(TEXT_INDEXES.key) != $INDEXES_key} {
                lappend results [list Sequence: $i  INPUT: Type is : $types Table : $table_name EXPECTED: Data: $INDEXES_data Header: $INDEXES_header Key: $INDEXES_key RETURNED: Data: $model(TEXT_INDEXES.data) Header: $model(TEXT_INDEXES.header) Key: $model(TEXT_INDEXES.key)]
            }
            set model(TEXT_INDEXES.data) ""
            set model(TEXT_INDEXES.header) ""
            set model(TEXT_INDEXES.key) ""
        }
        return $results
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
#DVT: 635378
test tcl_unit_getSchemaTriggerData {Unit test for getSchemaTriggerData} {
    -setup {}
    -body {
        set results ""
        # set the values in modelDef array
            updateInfo MODEL_FILES_DIRECTORY $MODEL_FILES_DIRECTORY
            setDefaultArray model target $modelConnection $targetConnection
        if {$getSchemaTriggerData_type == "negative"} {
            source $TEST_HOME/testdata/Array_Input_Output.txt
        }

        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            set table_name [ste tables$i]
            set TRIGGERS_data [set USER_TRIGGERS_data$i]
            set TRIGGERS_header [set USER_TRIGGERS_header$i]
            set TRIGGERS_key [set USER_TRIGGERS_key$i]
            #Calling proc getSchemaTriggerData
            if [catch {set result [getSchemaTriggerData model $targetConnection $table_name]} err] {
                return $err
            }
            if {$model(USER_TRIGGERS.data) != $TRIGGERS_data || $model(USER_TRIGGERS.header) != $TRIGGERS_header || $model(USER_TRIGGERS.key) != $TRIGGERS_key} {
                lappend results [list Sequence: $i  INPUT: Table : $table_name \nEXPECTED: Data: $TRIGGERS_data \nHeader: $TRIGGERS_header \nKey: $TRIGGERS_key  \nRETURNED: Data: $model(USER_TRIGGERS.data) \nHeader: $model(USER_TRIGGERS.header)) \nKey: $model(USER_TRIGGERS.key)]
            }
            set model(USER_TRIGGERS.data) ""
            set model(USER_TRIGGERS.header) ""
            set model(USER_TRIGGERS.key) ""
        }
            return $results
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
#DVT: 635379
test tcl_unit_getSchemaTriggers {Unit test for getSchemaTriggers} {
    -setup {}
    -body {
        set val ""
        if {$getSchemaTriggers_type == "positive"} {
            source $TEST_HOME/testdata/Array_Input_Output.txt
        }
        updateInfo MODEL_FILES_DIRECTORY $MODEL_FILES_DIRECTORY
        setDefaultArray model target $modelConnection $targetConnection
        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            set table_name [set tables$i]
            set Triggers_val [set getSchemaTriggers_val$i]
            #Calling proc getSchemaTriggers to get values in variable Results
            if [catch {set result [getSchemaTriggers $targetConnection Results target $table_name]} err] {
            }
            if {$Results != $Triggers_val} {
                lappend val "Sequence: $i INPUT: Table : $table_name EXPECTED: Schema Triggers Val: \n$Triggers_val \nRETURNED: Results: \n$Results"
            }
            set Results ""
        }
        return $val
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
#DVT: 635391
test tcl_unit_getSqlListMAP {Unit test for getSqlListMAP proc} {
    -setup {}
    -body {
        set result ""

        set result [getSqlListMAP]
        if {$result == $expectedResult} {
            return 0
        } else {
            return [list INPUT: "" EXPECTED: $expectedResult RETURNED: $result]
        }
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT: 635392
test tcl_unit_getSqlListPOST {Unit test for getSqlListPOST proc} {
    -setup {}
    -body {
        set result ""

        set result [getSqlListPOST]

        if {$result == $expectedResult} {
            return 0
        } else {
            return [list INPUT: "" EXPECTED: $expectedResult RETURNED: $result]
        }
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT: 635394
test tcl_unit_getSqlListPRE {Unit test for getSqlListPRE proc} {
    -setup {}
    -body {
        set result ""

        set result [getSqlListPRE]

        if {$result == $expectedResult} {
            return 0
        } else {
            return [list INPUT: "" EXPECTED: $expectedResult RETURNED: $result]
        }
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT: 634063
test tcl_unit_testOracleScriptLogon {Unit test for testOracleScriptLogon proc} {
    -setup {}
    -body {

        set retval ""

        set output1 $targetConnection
        catch {set result [testOracleScriptLogon $targetConnection]} err
        set file1 [glob -nocomplain *.bat]

        if {[file exists $file1] == 1} {
            file delete $file1
            return $err
        }

        if {$result != $output1} {
            lappend retval [list TYPE: $type INPUT:$targetConnection EXPECTED: $output1 RETURNED: $result]
        }
         return $retval


    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
#DVT: 635382
test tcl_unit_getScriptHistory {Unit test for getScriptHistory proc} {
    -setup {}
    -body {
            set rval ""

            if { [catch {getLogonHandle $targetConnection} dbh ] }  {
                puts "***ERROR - Cannot log onto $targetConnection"
                return "Unable to log onto database"
            } else {
                set length1 [llength [lindex [getScriptHistory $dbh] 0]]
                set length2 [llength [lindex [getScriptHistory $dbh] 1]]
                #inserting values in the schema to verify output of getScriptHistory procedure
                set sql "INSERT INTO SHS_SCHEMA_HISTORY (SHS_UID, SHS_TYPE, shs_version_new, shs_sql_script_name, SHS_DESC, SHS_DATE, SHS_TIME) values ( '2040371' ,'CREATE', '02.04.03.71', 'Testing UT', 'Testing', trunc(SYSDATE), TO_CHAR (SYSDATE,'HH24MI') )"
                catch {execsql use $dbh $sql "SQL_Error {$sql}"} err
                set sql "INSERT INTO SHS_SCHEMA_HISTORY (SHS_UID, SHS_TYPE, shs_version_new, shs_sql_script_name, SHS_DESC, SHS_DATE, SHS_TIME) values ( '2040372' ,'UPDATE', '02.04.03.71', 'Testing UT', 'Testing', trunc(SYSDATE), TO_CHAR (SYSDATE,'HH24MI') )"
                catch {execsql use $dbh $sql "SQL_Error {$sql}"} err
                set sql "INSERT INTO SHS_SCHEMA_HISTORY (SHS_UID, SHS_TYPE, shs_version_new, shs_sql_script_name, SHS_DESC, SHS_DATE, SHS_TIME) values ( '2040373' ,'UPDATE', '02.04.03.71', 'Testing UT', 'Testing', trunc(SYSDATE), TO_CHAR (SYSDATE,'HH24MI') )"
                catch {execsql use $dbh $sql "SQL_Error {$sql}"} err
                set sql "INSERT INTO SHS_SCHEMA_HISTORY (SHS_UID, SHS_TYPE, shs_version_new, shs_sql_script_name, SHS_DESC, SHS_DATE, SHS_TIME) values ( '2040374' ,'EB', '02.04.03.71', 'Testing UT', 'Testing', trunc(SYSDATE), TO_CHAR (SYSDATE,'HH24MI') )"
                catch {execsql use $dbh $sql "SQL_Error {$sql}"} err
                set sql "INSERT INTO SHS_SCHEMA_HISTORY (SHS_UID, SHS_TYPE, shs_version_new, shs_sql_script_name, SHS_DESC, SHS_DATE, SHS_TIME) values ( '2040375' ,'JUNK', '02.04.03.71', 'Testing UT', 'Testing', trunc(SYSDATE), TO_CHAR (SYSDATE,'HH24MI') )"
                catch {execsql use $dbh $sql "SQL_Error {$sql}"} err
                set length3 [llength [lindex [getScriptHistory $dbh] 0]]
                set length4 [llength [lindex [getScriptHistory $dbh] 1]]
                #getting the difference to validate the output of both the indexes of the return value
                set result1 [expr $length3-$length1]
                set result2 [expr $length4-$length2]
            }
            if {$result1 != $output || $result2 != $output} {
                lappend rval "Sequence: 1\nEXPECTED: $output\nRETURNED: result1=$result1, result2=$result2"
            }
            set sql "delete from SHS_SCHEMA_HISTORY where SHS_UID ='2040371'"
                catch {execsql use $dbh $sql "SQL_Error {$sql}"} err
                set sql "delete from SHS_SCHEMA_HISTORY where SHS_UID = '2040372'"
                catch {execsql use $dbh $sql "SQL_Error {$sql}"} err
                set sql "delete from SHS_SCHEMA_HISTORY where SHS_UID = '2040373'"
                catch {execsql use $dbh $sql "SQL_Error {$sql}"} err
                set sql "delete from SHS_SCHEMA_HISTORY where SHS_UID = '2040374'"
                catch {execsql use $dbh $sql "SQL_Error {$sql}"} err
                set sql "delete from SHS_SCHEMA_HISTORY where SHS_UID = '2040375"
                catch {execsql use $dbh $sql "SQL_Error {$sql}"} err
                catch {execsql use $dbh "commit" } err
        return $rval
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
#DVT: 635383
test tcl_unit_getScriptProduct {Unit test for getScriptProduct proc} {
    -setup {}
    -body {
        set rval ""

        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            set inputFile [set sqlfileInput$i]
            set output [set getScriptProductOut$i]

            set result [getScriptProduct $inputFile]
            if {$result != $output} {
                lappend rval "Scenario: $i\nEXPECTED: $output\nRETURNED: $result"
            }
            unset result
        }
        return $rval
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
#DVT: 635386
test tcl_unit_getSHSscripts {Unit test for getSHSscripts proc} {
    -setup {}
    -body {
          set result ""
          if { [catch {getLogonHandle $targetConnection} dbh ] }  {
              puts "***ERROR - Cannot log onto $targetConnection"
              lappend result "Unable to log onto database"
              set i 0
          } else {
              set ver_lst ""
              set scr_lst ""
              set res_lst ""
              set SQL "select shs_version_new, shs_sql_script_name, shs_results
              into :ver_lst,
              :scr_lst,
              :res_lst
              from shs_schema_history where shs_type in ('CREATE','UPDATE','EB','CUSTOM')
              order by shs_uid desc"
              catch {execsql use $dbh $SQL} err
              if {$err < 0} {lappend result "Unable to get schema history"}
              set getSHSscriptsOut [list $ver_lst $scr_lst $res_lst]

              set result [getSHSscripts $dbh]
              set i 1
          }

          if { $result == $getSHSscriptsOut} {
              return 0
          } else {
            lappend result [list Sequence: $i INPUT: $connectionString EXPECTED: $getSHSscriptsOut RETURNED: $result]
            return $result
          }

    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT: 634087
test tcl_unit_getCodeVals {Unit test for proc getCodeVals} {
    -setup { set validNegatives "" }
    -body {
        set retVal ""
        lappend validNegatives {couldn't open \"$TEST_HOME/testdata/NONEXISTANT_NAMES_634087.txt\": no such file or directory}
        lappend validNegatives {couldn't open \"$TEST_HOME/testdata/NONEXISTANT_VALUES_634087.txt\": no such file or directory}
        set validNegatives [ subst $validNegatives ]

        # Positive Scenarios
        # Scenario 1 : Happy flow
        # Scenario 2 : Empty Names file
        # Scenario 3 : Empty Values file
        # Scenario 4 : Names file with only a header
        # Scenario 5 : Values file with only a header
        # Negative Scenarios
        # Scenario 1 : Missing Names file
        # Scenario 2 : Missing Values file

        if {$xmlVerNum == "03010100" && $condition == "le"} {
            for {set counter 1} {$counter <= $totalCases} {incr counter} {
            set res "[set sampleResults$counter]"
            set inputName "[set sampleNamesFile$counter]"
            set inputValue "[set sampleValuesFile$counter]"
            set gcvResult ""

                if { [catch {set gcvResult [getCodeVals $inputName $inputValue client_tables]} r] } {
                    if {$testType == "NEGATIVE"} {
                        if {[lsearch $validNegatives $r] < 0} {
                            lappend retVal "TEST-TYPE: $testType SEQUENCE: $counter EXPECTED:  $res RETURNED: Error-$r"
                        }
                        # Else it's a valid negative scenario
                    } else {
                        lappend retVal "TEST-TYPE: $testType SEQUENCE: $counter EXPECTED:  $res RETURNED: Error-$r"
                    }
                } else {
                    if { $res != $gcvResult} {
                        lappend retVal "TEST-TYPE: $testType SEQUENCE: $counter EXPECTED: $res RETURNED: $gcvResult"
                    }
                }
            }
        } elseif {$xmlVerNum >= 03020000 && $condition == "ge"} {
            for {set counter 1} {$counter <= $totalCases} {incr counter} {
                set res "[set sampleResults$counter]"
                set inputName "[set sampleNamesFile$counter]"
                set inputValue "[set sampleValuesFile$counter]" 
                set inputWhere "[set sampleWhereFile$counter]"
                set inputTable "[set sampleclienttable$counter]" 
                
                set gcvResult ""
                set source_where_file  $inputWhere
                array set client_tables [getClientTables "$source_where_file"]

                if { [catch {set gcvResult [getCodeVals $inputName $inputValue client_tables]} r] } {
                    if {$testType == "NEGATIVE"} {
                        if {[lsearch $validNegatives $r] < 0} {
                            lappend retVal "TEST-TYPE: $testType SEQUENCE: $counter EXPECTED: $res RETURNED: Error-$r"
                        }
                        # Else it's a valid negative scenario
                    } else {
                        lappend retVal "TEST-TYPE: $testType SEQUENCE: $counter EXPECTED: $res RETURNED: Error-$r"
                    }
                } else {
                    if {$res != $gcvResult} {
                        lappend retVal "TEST-TYPE: $testType SEQUENCE: $counter EXPECTED: $res RETURNED: $gcvResult"
                    }
                }
            }
        } else { lappend retVal "Skipped: $xmlVerNum" }

        return $retVal
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
#DVT: 635820
test tcl_unit_processAddTrigger {Unit test for processAddTrigger} {
    -setup {}
    -body {
        set rval 0
        # set the values in model array
        updateInfo MODEL_FILES_DIRECTORY $MODEL_FILES_DIRECTORY
        setDefaultArray modelDef targetDef $modelConnection $targetConnection
        if {$caseType != "negative"} {
            for {set i 1} {$i <= $no_of_scenarios} {incr i} {
                set inputVal [set value$i]
                set output [set expected_Result$i]

                #Calling proc addResult to add value and type in Glabal array RESULT
                addResult $type $inputVal
                global WARNINGS
                array set WARNINGS {ADD.TRIGGERS {}}
                #Calling proc processAddTrigger
                if [catch {set result [processAddTrigger Results]} err] {
                    lappend rval "processAddTrigger error: $err"
                }
                set val [string match "*[lindex $output 0]" [lindex $result 0]]
                if {$val != 1} {
                    if {$result != $output} {
                        lappend rval "Sequence: $i Case Type: $caseType\nEXPECTED: $output\nRETURNED: $result"
                    }
                }
                unset RESULTS
            }
        } else {
            global WARNINGS
            array set WARNINGS {ADD.TRIGGERS {}}
            #Calling proc processAddTrigger
            if [catch {set result [processAddTrigger Results]} err] {
                if {$err != $expected_error} {
                    lappend rval "Sequence: ? Case Type: $caseType\nEXPECTED: $expected_error\nRETURNED: $err"
                }
            }
        }
        return $rval
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT: 634086
test tcl_unit_getCodesInModel {Unit test for proc getCodesInModel} {
    -setup {}
    -body {
        set err ""
        # Scenario 1 : Happy flow
        # Scenario 2 : Values file with only a header
        for {set counter 1} {$counter <= $totalCases} {incr counter} {
            set res [set "sampleResults$counter"]
            set tableName [set tableName$counter]
            set columnName [set columnName$counter]
            set gcimResult ""
            set sampleValuesFile [set "sampleValuesFile$counter"]
            if {[catch {set fp [open $sampleValuesFile r]} er] } {
                lappend err "SEQUENCE: $counter EXPECTED: TableName-$tableName ColumnName-$columnName RETURNED: Error-$er"
                continue
            }
            gets $fp fileTemp
            gets $fp fileTemp
            set gcimResult [getCodesInModel $tableName $columnName $fp]
            close $fp
            if {$res != $gcimResult} {
                lappend err "SEQUENCE: $counter EXPECTED: TableName-$tableName ColumnName-$columnName RETURNED: $gcimResult"
            }
        }
        return $err
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}

# DVT 635723 -  RE AT test for getDBDate
test tcl_unit_p_getDbDate {Unit test for getDBDate proc} {
    -setup {}
    -body {
        set rval ""
        # set database "UNIT_CR2430/UNIT_CR2430@cic-svr-db08-orcl"
        if { [catch {getLogonHandle $targetConnection} dbh] }  {
            puts "***ERROR - Cannot log onto $targetConnection"
            return 1
        }
        set result [p_getDbDate $dbh]

        set testDate [clock format [clock seconds] -format %Y\ %b\ %d]
        set finalDate [string toupper $testDate]

        if {$result != $finalDate} {
            lappend rval "EXPECTED: $finalDate RETURNED: $result"
        }
        if {$rval != ""} {
            return $rval
        }
        return 0
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT: 635811
test tcl_unit_parse_column {Unit test for parse_column proc} {
    -setup {}
    -body {
        set rval ""

        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            set inputCoulmnIn [set columnIn$i]
            set output [set parse_columnOut$i]

            set result [parse_column $inputCoulmnIn]
            if { $result != $output} {
                lappend rval "Sequence: $i\nEXPECTED: $output\nRETURNED: $result"
            }
        }
        return $rval
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
#DVT: 635810
test tcl_unit_parse_clause {Unit test for parse_clause proc} {
    -setup {}
    -body {

        set rval ""

        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            set inputCoulmnIn [set columnIn$i]
            set output [set parse_clauseOut$i]

            set result [parse_clause $inputCoulmnIn]
            if { $result != $output} {
                lappend rval "Sequence: $i\nEXPECTED: $output\nRETURNED: $result"
            }
        }
        return $rval
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
#DVT: 634084
test tcl_unit_get_Rtargets {Unit test for proc get_Rtargets} {
    -setup {}
    -body {
        source $sampleDataFile
        set err ""
        # Scenarios tested
        # 1. get constraint info from Schema
        # 2. get constraint info from Model Files
        # 3. get constraint info from the input array itself
        for {set counter 1} {$counter <= $totalCases} {incr counter} {
            set res [set getRtargetRes$counter]
            set rConstraint [set rConstraint$counter]
            set sampleArray [set sampleArray$counter]
            set ${sampleArray}(connectionString) $targetConnection
            set getR  [get_Rtargets $sampleArray $rConstraint]
            if {$getR != $res} {
                lappend err "SEQUENCE: $counter INPUT: Constraint-$rConstraint EXPECTED: $res RETURNED: $getR"
            }
        }
        return $err
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
#DVT: 635395
test tcl_unit_getTargetDriverRow {Unit test for proc getTargetDriverRow} {
    -setup {}
    -body {
        set err ""
        # Scenario 1. get last line of AutoConversion.txt
        set res [getTargetDriverRow $sampleAutoCon1]
        if {$res != $targetRowRes1} {
            lappend err "SEQUENCE:1  INPUT:$sampleAutoCon1  EXPECTED:$targetRowRes1 RETURNED:$res"
        }
        # Scenario 2. get line of AutoConversion.txt for a specific version
        set res [getTargetDriverRow $sampleAutoCon1 $sampleVer1]
        if {$res != $targetRowRes2} {
            lappend err "SEQUENCE:2  INPUT: Connection-$sampleAutoCon1 Version-$sampleVer1  EXPECTED:$targetRowRes2 RETURNED:$res"
        }
        # Scenario 3. get first line if there are multiple lines with the same version
        set res [getTargetDriverRow $sampleAutoCon1 $sampleVer2]
        if {$res != $targetRowRes3} {
            lappend err "SEQUENCE:3  INPUT: Connection-$sampleAutoCon1 Version-$sampleVer1  EXPECTED:$targetRowRes3 RETURNED:$res"
        }
        # Scenario 4. get blank line from an empty AutoConversion file
        set res [getTargetDriverRow $sampleAutoCon2]
        if {$res != $targetRowRes4} {
            lappend err "SEQUENCE:4  INPUT:$sampleAutoCon2  EXPECTED:$targetRowRes4 RETURNED:$res"
        }
        # Scenario 5. test proc for a non-existant file
        if { [catch {set res [getTargetDriverRow $sampleAutoCon3]} ero]} {
            if {$ero != $targetRowRes5} {
                lappend err "SEQUENCE:5  INPUT:$sampleAutoCon3  EXPECTED:$targetRowRes5 RETURNED:$ero"
            }
        } else {
            lappend err "SEQUENCE:5  INPUT:$sampleAutoCon3  EXPECTED:$targetRowRes5 RETURNED:$
            $res"
        }
        return $err
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
# DVT 635723 -  RE AT test for p_getCurrModDir
test tcl_unit_p_getCurrModDir {Unit test for p_getCurrModDir proc} {
    -setup {}
    -body {
        set rval ""

            for {set i 1} {$i <= 2} {incr i} {
                set inputDriverFile [set driverFile$i]
                set inputCurrentVersion [set currentVersion$i]
                set inputShortVersion [set shortVersion$i]
                # Calling proc p_getCurrModDir
                set result [p_getCurrModDir $inputDriverFile $inputCurrentVersion $inputShortVersion]
                if {$result != $modelDir} {
                    lappend rval "Sequence: $i EXPECTED: $modelDir RETURNED: $result"
                }
            }
        if {$rval != ""} {
            return $rval
        }
        return 0
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT: 635387
test tcl_unit_getSHSupdate {Unit test for getSHSupdate proc} {
    -setup {}
    -body {
          set result ""
          set SQL [getSHSupdate $script_name $oldversion]
          #Scenario1: Checking valid return value
          if { $SQL != $getSHSupdateOut} {
            lappend result "$getSHSupdateReturn Incorrect SQL generated by proc: $SQL"
          }

          #Scenario2: Checking the generated sql

          if { [catch {getLogonHandle $targetConnection} dbh ] }  {
            puts "***ERROR - Cannot log onto $targetConnection"
            lappend result "$getSHSupdateReturn Unable to log onto database"
          } else {
            # Updating the table with a test value
            set preSQL "UPDATE  SHS_SCHEMA_HISTORY
                SET SHS_RESULTS = 'TestResult',
                SHS_LAST_UPDATE_DATE = sysdate,
                SHS_USR_UID_UPDATED_BY = -4
                where SHS_SQL_SCRIPT_NAME = '$script_name'"
            catch {execsql use $dbh $preSQL} err1
            execsql use $dbh "Commit"

            #preparing select query
            set shs_res ""
            set preSQL2 "SELECT SHS_RESULTS
                into :shs_res
                from SHS_SCHEMA_HISTORY
                where SHS_SQL_SCRIPT_NAME = '$script_name'"
            catch {execsql use $dbh $preSQL2} err2
            #Confirming if the value is properly updated
            if { $shs_res == "TestResult"} {
              #Now updating the table using the sql generated by the proc getSHSupdate
              catch {execsql use $dbh $SQL} err
              execsql use $dbh "Commit"
              if {!($err == 0 || $err == 100)} {
                lappend result "$getSHSupdateReturn SQL failure."
              } else {
                set shs_res ""
                catch {execsql use $dbh $preSQL2} err3
                #Confirming the value after update using the query generated by the proc
                if { $shs_res != "Successful"} {
                    lappend result "$getSHSupdateReturn Update not working using the query generated by the proc"
                }
              }
            }
          }
          execsql use $dbh "delete from SHS_SCHEMA_HISTORY where SHS_SQL_SCRIPT_NAME = '$script_name'"
          execsql use $dbh "commit"
          logoff $dbh
          if {$result == ""} {
            return 0
          } else {
            return $result
          }

    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
# DVT 635803 -  RE AT test for p_getTargetModDir
test tcl_unit_p_getTargetModDir {Unit test for p_getTargetModDir proc} {
    -setup {}
    -body {
        set rval ""
        for {set i 1} {$i <=2} {incr i} {
            set inputDriver [set driverFile$i]
            set inputShortTarget [set shortTargetVersion$i]
            set output [set targetmodelDir$i]

            set result [p_getTargetModDir $inputDriver $inputShortTarget]

            if {$result != $output} {
                lappend rval "Sequence: $i EXPECTED: $output RETURNED: $result"
            }
        }
        if {$rval != ""} {
            return $rval
        }
        return 0
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT: 635711
test tcl_unit_makeDir {Unit test for makeDir proc} {
    -setup {}
    -body {
        set reval 0
        set err ""

        set directory $TCL_UNIT_TEST_WORKING_DIR/[file normalize $directory]
        set result [makeDir $directory]

        if {!($result == $directory)} {
            lappend reval [list INPUT: $directory EXPECTED: $directory RETURNED: $result]
        }

        file delete -force $directory
        return $reval
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT: 634362
test tcl_unit_getResultNames {Unit test for getResultNames proc} {
    -setup {}
    -body {
        set result ""

        set result [getResultNames]
        if {$result == $expected_result} {
            return 0
        } else {
            return 1
        }
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT: 635814
test tcl_unit_processAddIndex {Unit test for processAddIndex} {
    -setup {}
    -body {
        source $TEST_HOME/testdata/Array_Input_Output.txt
        set rval ""
        #Calling proc addResult to add value and type in Glabal array RESULT
        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            set expectedResult [set expected_Result$i]
            if {$processAddIndex_type == "positive"} {
                set sample_Res [set sampleRes$i]
                setNullResults
                array set RESULTS [array get $sample_Res]
                global WARNINGS
                array set WARNINGS {ADD.INDEXS {}}
            }
            #Calling proc processAddIndex
            if [catch {set result [processAddIndex RESULTS $type]} err] {
                if {$err == $expectedResult} {
                    continue
                } else {
                    lappend rval [list Sequence: $i  INPUT: Scenario Type: $processAddIndex_type EXPECTED: $expectedResult RETURNED: $err]
                    continue
                }
            }
            set val [string match *[lindex $expectedResult 0] [lindex $result 0]]
            if {$val != 1} {
                if {$result != $expectedResult} {
                    lappend rval [list Sequence: $i  INPUT: Scenario Type: $processAddIndex_type EXPECTED: $expectedResult RETURNED: $result]
                }
            }
            unset RESULTS
            unset WARNINGS
        }
        return $rval
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
#DVT: 635818
test tcl_unit_processAddTable {Unit test for processAddTable} {
    -setup {}
    -body {
        source $TEST_HOME/testdata/Array_Input_Output.txt
        set rval ""
        #set the values in model array
        updateInfo MODEL_FILES_DIRECTORY $MODEL_FILES_DIRECTORY
        setDefaultArray model target $modelConnection $targetConnection
        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            # set sample_Res [set sampleRes$i]
            set expectedResult [set expected_Result$i]
            if {$processAddTable_type == "positive"} {
                set typeTables [set type_Tables$i]
                set values [set value$i]
                set typeCol [set type_typeCol$i]
                set valuetypeCol [set value_typeCol$i]
                addResult $typeTables $values
                addResult $typeCol $valuetypeCol
                global WARNINGS
                array set WARNINGS {ADD.TABLES {} ADD.TAB_COLS {}}
            }
            #Calling proc processAddTable
            if [catch {set result [processAddTable Results]} err] {
                if {$err == $expectedResult} {
                    continue
                } else {
                    lappend rval [list Sequence: $i  INPUT: Scenario Type: $processAddTable_type EXPECTED: $expectedResult RETURNED: $err]
                    continue
                }
            }
            set val [string match "*[lindex $expectedResult 0]" [lindex $result 0]]
            if {$val != 1} {
                if {$result != $expectedResult} {
                    lappend rval [list Sequence: $i  INPUT: Scenario Type: $processAddTable_type EXPECTED: $expectedResult RETURNED: $result]
                }
            }
            unset RESULTS
            unset WARNINGS
        }
        return $rval
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
#DVT: 635399
test tcl_unit_getVersionModDirName {Unit test for proc getVersionModDirName} {
    -setup {}
    -body {
        set err ""
        # Scenario 1. get ModDir from AutoConversion.txt
        # Scenario 2. get ModDir from AutoConversion.txt where same version is present in multiple lines
        # Scenario 3. get ModDir from AutoConversion.txt when version doe not exist
        # Scenario 5. call without path
        # Scenario 4. missing AutoConversion.txt file
        for {set i 1} {$i <= $totalCases} {incr i} {
            set ver [set sampleVer$i]
            set path [set samplePath$i]
            set res [set modRes$i]
            set resDir ""
            if {$path != "Skip"} {
                set resDir [getVersionModDirName $ver $path]
            } else {
                set resDir [getVersionModDirName $ver]
            }
            if {$res != $resDir} {
                lappend err "SEQUENCE:$i  INPUT:Version-$ver Path-$path  EXPECTED:$res  RETURNED:$resDir"
            }
        }
        return $err
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
#DVT: 635401
test tcl_unit_isInfo {Unit test for isInfo proc} {
    -setup {}
    -body {
          set result ""
          if {$isInfo_names != "negative"} {
            for {set i 1} {$i <= 10} {incr i} {
              set inpVar [set nameIn$i]
              # set outVar [set isInfoOut$i]
              set res [isInfo $inpVar]
              if { $res != $isInfoOut1} {
                  lappend result [list Sequence: $i INPUT: $inpVar EXPECTED: $isInfoOut1 RETURNED: $res]
              }
            }
          } else {
            set res [isInfo $nameIn11]
            if { $res != $isInfoOut2} {
                lappend result [list INPUT: $nameIn11 EXPECTED: $isInfoOut2 RETURNED: $res]
            }
          }
          if {$result == ""} {
            return 0
          } else {
             return $result
          }
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT: 635815
test tcl_unit_processAddProcedure {Unit test for processAddProcedure proc} {
    -setup {}
    -body {
        set result ""
        source $arrayInputOutputFile
        updateInfo MODEL_FILES_DIRECTORY $MODEL_FILES_DIRECTORY
        setDefaultArray model target $modelConnection $targetConnection
        setNullResults
        addResult $type $value
        set result [processAddProcedure ADD.PROCEDURES]

        if {$result == $expected_result} {
            return 0
        } else {
            return [list INPUT: ADD.PROCEDURES EXPECTED: $expected_result RETURNED: $result]
        }
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT: 635819
test tcl_unit_processAddTI {Unit test for processAddTI} {
    -setup {}
    -body {
        set rval ""
        # set the values in model array
        updateInfo MODEL_FILES_DIRECTORY $MODEL_FILES_DIRECTORY
        setDefaultArray model target $modelConnection $targetConnection

        if {$caseType != "negative"} {
            for {set i 1} {$i <= $no_of_scenarios} {incr i} {
                set inputValue [set value$i]
                set outputValue [set expected_Result$i]

                #Calling proc addResult to add value and type in Glabal array RESULT
                addResult ADD.$type\S $inputValue
                global WARNINGS
                array set WARNINGS {ADD.TEXT_INDEXS {}}

                #Calling proc processAddTI
                if [catch {set result [processAddTI Results ADD $type]} err] {
                    return $err
                }
                set val [string match "*[lindex $outputValue 0]" [lindex $result 0]]
                if {$val != 1} {
                    lappend rval "Sequence: $i CaseType: $caseType\nEXPECTED: $outputValue\nRETURNED: $result"
                }
                unset RESULTS
                unset WARNINGS
            }
        } else {
                global WARNINGS
                array set WARNINGS {ADD.TEXT_INDEXS {}}
                #Calling proc processAddTI
                if [catch {set result [processAddTI Results ADD $type]} err] {
                    if {$err != $expected_error} {
                        lappend rval "Sequence: 1 Case Type: $caseType\nEXPECTED: $expected_error\nRETURNED: $err"
                    }
                }
            }
            return $rval
        }
    -result {  }
    -cleanup {dropAll dbCompare}
}
# DVT: 635724
test tcl_unit_p_getParams {Unit test for proc p_getParams} {
    -setup {}
    -body {
        set err ""
        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            set sVal [set sampleVal$i]
            set sName [set scriptName$i]
            set retVal [set result$i]
            if {[file exists "input_params.txt"]} {
                catch {file delete input_params.txt} err1
            }
            if {$i == 4} {
                catch {file copy ../../tests/testdata/input_params.txt .} err1
            }
            catch {set res [p_getParams $sVal $sName]} retErr
            if {$scenario_type == "positive"} {
                if {$res != $retVal} {
                    lappend err "SEQUENCE:$i  INPUT:$sVal  EXPECTED:$retVal RETURNED:$res"
                }
            } else {
                if {$retErr != $retVal} {
                lappend err "SEQUENCE:$i  INPUT:$sVal  EXPECTED:$retVal RETURNED:$retErr"
            }
            }
        }
        return $err
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}

#DVT: 635804
test tcl_unit_p_interpose {Unit test for proc p_interpose} {
    -setup {}
    -body {
        set err ""

        # Scenario 1. Valid version, default token & default count
        if {[p_interpose $sampleVer1] != $result1} {
            lappend err "SEQUENCE:1  INPUT:Version-$sampleVer1  EXPECTED:$result1  RETURNED:[p_interpose $sampleVer1]"
        }

        # Scenario 2. Valid version, valid token & default count
        if {[p_interpose $sampleVer2 $sampleToken2] != $result2} {
            lappend err "SEQUENCE:2  INPUT:Version-$sampleVer2 Token-$sampleToken2  EXPECTED:$result2  RETURNED:[p_interpose $sampleVer2 $sampleToken2]"
        }

        # Scenario 3. Valid version, token & count
        if {[p_interpose $sampleVer3 $sampleToken3 $sampleCount3] != $result3} {
            lappend err "SEQUENCE:3  INPUT:Version-$sampleVer3 Token-$sampleToken2 Count-$sampleCount3  EXPECTED:$result3  RETURNED:[p_interpose $sampleVer3 $sampleToken3 $sampleCount3]"
        }

        # Scenario 4. No version in input
        if {[p_interpose $sampleVer4] != $result4} {
            lappend err "SEQUENCE:4  INPUT:Version-$sampleVer4  EXPECTED:$result4  RETURNED:[p_interpose $sampleVer4]"
        }

        # Scenario 5. Length of Version not completely divisible by default count
        if {[catch {[p_interpose $sampleVer5]} er]} {
            if {$er != $result5} {
                lappend err "SEQUENCE:5  INPUT:$sampleVer5  EXPECTED:$result5  RETURNED:$er"
            }
        } else {
            lappend err "SEQUENCE:5  INPUT:$sampleVer5  EXPECTED:$result5  RETURNED:[p_interpose $sampleVer5]"
        }

        # Scenario 6. Length of Version not completely divisible by user-defined count
        if {[catch {[p_interpose $sampleVer6 "." $sampleCount6]} er]} {
            if {$er != $result6} {
                lappend err "SEQUENCE:6  INPUT:Version-$sampleVer6 Token-. Count-$sampleCount6  EXPECTED:$result6  RETURNED:$er"
            }
        } else {
            lappend err "SEQUENCE:6  INPUT:Version-$sampleVer6 Token-. Count-$sampleCount6  EXPECTED:$result6  RETURNED:[p_interpose $sampleVer6 "." $sampleCount6]"
        }

        return $err
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
#DVT: 635816
test tcl_unit_processAddSeqEntry {Unit test for processAddSeqEntry proc} {
    -setup {}
    -body {
        set result ""
        source $arrayInputOutputFile
        updateInfo MODEL_FILES_DIRECTORY $MODEL_FILES_DIRECTORY
        setDefaultArray model target $modelConnection $targetConnection
        setNullResults
        addResult $type $value
        set result [processAddSeqEntry INSERT.SEQS]
        set val [string match *[lindex $expected_result 0] [lindex $result 0]]
        if {$val != 1} {
            if {$result != $expected_result} {
                return [list INPUT: INSERT.SEQS EXPECTED: $expected_result RETURNED: $result]
            }
        }
        return 0
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
# DVT 635821 - Process Backup
test tcl_unit_processBackup1.1 {Unit test for processBackup} {
    -setup {}
    -body {
        # set the values in model array
        updateInfo MODEL_FILES_DIRECTORY $MODEL_FILES_DIRECTORY
        setDefaultArray modelDef targetDef $modelConnection $targetConnection
        # Calling proc addResult to add value and type in global array result
        addResult $type $value1
        addResult $type $value2

        # Calling proc processAddColumn
        if [catch {set result [processBackup modelDef]} err] {
            return $err
        }
        if {$result == $expected_Result} {
            return 0
        } else {
            return "Expected result should be $expected_Result\n but its returning result $result"
        }

    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT: 635813
test tcl_unit_processAddConstraint {Unit test for processAddConstraint} {
    -setup {}
    -body {
        set rval ""
        # set the values in model array
        updateInfo MODEL_FILES_DIRECTORY $MODEL_FILES_DIRECTORY
        setDefaultArray model target $modelConnection $targetConnection
        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            set table_type [set type$i]
            set type_value [set value$i]
            set expectedResult [set expected_Result$i]
            #Calling proc addResult to add value and type in Glabal array RESULT
            if {$processAddConstraint_type == "positive"} {
                addResult $table_type $type_value
                global WARNINGS
                array set WARNINGS {ADD.CONSTRAINTS {}}
            }
            #Calling proc processAddConstraint
            if [catch {set result [processAddConstraint Results $table_type]} err] {
                if {$err == $expectedResult} {
                    continue
                } else {
                    lappend rval [list Sequence: $i  INPUT: Type: $table_type Value: $type_value EXPECTED: $expectedResult RETURNED: $err]
                    continue
                }
            }
            set val [string match "*[lindex $expectedResult 0]" [lindex $result 0]]
            if {$val != 1} {
                if {$result != $expectedResult} {
                    lappend rval [list Sequence: $i  INPUT: Type: $table_type Value: $type_value EXPECTED: $expectedResult RETURNED: $result]
                }
            }
            unset RESULTS
            unset WARNINGS
        }
        return $rval

    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
# DVT: 635808
test tcl_unit_p_splitat {Unit test for proc p_splitat} {
    -setup {}
    -body {
        set err ""
        # Scenario 1. Valid version, default count
        # Scenario 2. Valid version, user-defined count
        # Scenario 3. Blank version
        # Scenario 4. Non-version string
        for {set i 1} {$i <= $totalCases} {incr i} {
            set ver [set sampleVer$i]
            set count [set sampleCount$i]
            set res [set result$i]
            if {$count == "Skip"} {
                if {[p_splitat $ver] != $res} {
                    lappend err [list SEQUENCE:$i INPUT:Version-$ver EXPECTED:$res RETURNED:[p_splitat $ver]]
                }
            } else {
                if {[p_splitat $ver $count] != $res} {
                    lappend err [list SEQUENCE:$i "INPUT:Version-$ver Count-$count" EXPECTED: $res RETURNED:[p_splitat $ver $count]]
                }
            }
        }
        return $err
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
# DVT: 635805
test tcl_unit_p_pad_version {Unit test for proc p_pad_version} {
    -setup {}
    -body {
        set err ""
        # Scenario 1. Valid version
        # Scenario 2. Single digit version
        # Scenario 3. Blank version
        for {set i 1} {$i <= $totalCases} {incr i} {
            set ver [set sampleVer$i]
            set res [set result$i]
            if {[p_pad_version $ver] != $res} {
                lappend err [list SEQUENCE:$i  INPUT:$ver  EXPECTED:$res RETURNED:[p_pad_version $ver]]
            }
        }
        return $err
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
#DVT: 635817
test tcl_unit_processAddSequence {Unit test for processAddSequence proc} {
    -setup {}
    -body {
        set result ""
        source $arrayInputOutputFile
        updateInfo MODEL_FILES_DIRECTORY $MODEL_FILES_DIRECTORY
        setDefaultArray model target $modelConnection $targetConnection
        setNullResults
        addResult $type $value
        set result [processAddSequence ADD.SEQUENCES]
        set val [string match "*[lindex $expected_result 0]" [lindex $result 0]]
        if {$val != 1} {
            if {$result != $expected_result} {
                return [list INPUT: ADD.SEQUENCES EXPECTED: $expected_result RETURNED: $result]
            }
        }
        return 0
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
# DVT: 635809
test tcl_unit_p_unpad_version {Unit test for proc p_unpad_version} {
    -setup {}
    -body {
        set err ""
        # Scenario 1. Version with leading zeroes
        # Scenario 2. Version with trailing zeroes
        # Scenario 3. Blank version
        # Scenario 4. All leading zeroes
        # Scenario 5. All single digit version components
        # Scenario 6. Replacement of a version component with all zeroes by a single 0
        for {set i 1} {$i <= $totalCases} {incr i} {
            set version [set sampleVer$i]
            set result [set result$i]
            if {[p_unpad_version $version] != $result} {
                lappend err [list SEQUENCE:$i  INPUT: $version  EXPECTED: $result  RETURNED:[p_unpad_version $version]]
            }
        }
        return $err
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
#DVT: 635712
test tcl_unit_makeTypeDDL {Unit test for makeTypeDDL proc} {
    -setup {}
    -body {
          source $sampleDataFileIn

          set result ""
          if {$makeTypeDDL_names == "positive"} {
            for {set i 1} {$i <= 6} {incr i} {
              set inpVar [set typeIn$i]
              set outVar [set makeTypeDDLOut$i]
              set res [makeTypeDDL makeTypeDDLrSQL $inpVar]
              if { $res != [set $outVar] } {
                  lappend result [list Sequence: $i INPUT: $inpVar EXPECTED: $outVar RETURNED: $res]
              }
            }
          } else {
            catch {set res [makeTypeDDL makeTypeDDLrSQL $typeIn7]} err
              if {$err != $makeTypeDDLOut7} {
                 lappend result [list Sequence: 1 INPUT: $typeIn7 EXPECTED: $makeTypeDDLOut7 RETURNED: $err]
              }
          }
          if {$result == ""} {
            return 0
          } else {
             return $result
          }

    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
# DVT 635812 - Process Add Column
test tcl_unit_processAddColumn {Unit test for processAddColumn} {
    -setup {}
    -body {
        set rval ""
        # set the values in model array
        updateInfo MODEL_FILES_DIRECTORY $MODEL_FILES_DIRECTORY
        setDefaultArray modelDef targetDef $modelConnection $targetConnection
        if {$processAddColumn != "negative"} {
            for {set i 1} {$i <= 2} {incr i} {

                set inputVal1 [set avalue$i]
                set inputVal2 [set bvalue$i]
                set inputVal3 [set cvalue$i]
                set inputVal4 [set dvalue$i]
                set output [set expected_Result$i]

                # Calling proc addResult to add value and type in global array result
                addResult $type $inputVal1
                addResult $type $inputVal2
                addResult $type $inputVal3
                addResult $type $inputVal4

                global WARNINGS
                array set WARNINGS {ADD.COLUMNS {}}

                # Calling proc processAddColumn
                if [catch {set result [processAddColumn ""]} err] {
                    return $err
                }
                if {$result != $output} {
                    lappend rval "Sequence: $i Case Type: $processAddColumn\nEXPECTED: $output\nRETURNED: $result"
                }
                # unset DBS_INFO(DEF.TYPES)
            }
        }   else {
                # Calling proc processAddColumn
                if [catch {set result [processAddColumn ""]} err] {
                    if {$err != $expected_error} {
                        lappend rval "Sequence: 2 Case Type: $processAddColumn\nEXPECTED: $expected_error\nRETURNED: $err"
                    }
                }
            }
            if {$rval != ""} {
                lappend $rval
            }
            return 0
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
# DVT 635821 - Process Backup
test tcl_unit_processBackup1.1 {Unit test for processBackup} {
    -setup {}
    -body {
        # set the values in model array
        updateInfo MODEL_FILES_DIRECTORY $MODEL_FILES_DIRECTORY
        setDefaultArray modelDef targetDef $modelConnection $targetConnection
        # Calling proc addResult to add value and type in global array result
        addResult $type $value1
        addResult $type $value2

        # Calling proc processAddColumn
        if [catch {set result [processBackup modelDef]} err] {
            return $err
        }
        if {$result == $expected_Result} {
            return 0
        } else {
            return "Expected result should be $expected_Result\n but its returning result $result"
        }

    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT: 635806
test tcl_unit_p_padTo {Unit test for proc p_padTo} {
    -setup {}
    -body {
        set err ""
        # Scenario 1. Only version passed
        if {[p_padTo $sampleVer1] != $result1} {
            lappend err "SEQUENCE:1  INPUT:Version-$sampleVer1  EXPECTED:$result1  RETURNED:[p_padTo $sampleVer1]"
        }
        # Scenario 2. Version & count passed
        if {[p_padTo $sampleVer2 $sampleCount2] != $result2} {
            lappend err "SEQUENCE:2  INPUT:Version-$sampleVer2 Count-$sampleCount2  EXPECTED:$result2  RETURNED:[p_padTo $sampleVer2 $sampleCount2]"
        }
        # Scenario 3. Version, count & padding character passed
        if {[p_padTo $sampleVer3 $sampleCount3 $sampleChar3] != $result3} {
            lappend err "SEQUENCE:3  INPUT:Version-$sampleVer3 Count-$sampleCount3 Char-$sampleChar3  EXPECTED:$result3  RETURNED:[p_padTo $sampleVer3 $sampleCount3 $sampleChar3]"
        }
        # Scenario 4. Count already less than length of Version
        if {[p_padTo $sampleVer4 $sampleCount4] != $result4} {
            lappend err "SEQUENCE:4  INPUT:Version-$sampleVer4 Count-$sampleCount4  EXPECTED:$result4  RETURNED:[p_padTo $sampleVer4 $sampleCount4]"
        }
        return $err
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
#DVT: 635822
test tcl_unit_processDifferences21.1 {Unit test for processDifferences2} {
    -setup {}
    -body {
        set rval ""
        # set the values in model array
        updateInfo MODEL_FILES_DIRECTORY $MODEL_FILES_DIRECTORY
        setDefaultArray model target $modelConnection $targetConnection
        foreach inputName $inputNames {
            set outputName $inputName\_out
            #start with no results
            setNullResults
            if {$inputName == "add_Table"} {
                addResult ADD.TAB_COLS $value_typeCol
            }
            set values [set $inputName]
            set listType [lindex $values 0]
            set objectType [lindex $values 1]
            set value [lindex $values 2]
            set expected [set $outputName]
            #add diff to appropriate list
            add$listType $objectType $value
            array set sql [processDifferences2]
            # this could be made more robust by checking that no other objecttype got populated.
            set returned $sql([string trimright $objectType "S"])
            regsub -all {[\t ]} $returned "" returned
            regsub -all {[\t ]} $expected "" expected
            if {$returned != $expected} {
                lappend rval "INPUTS: $listType $objectType $value EXPECTED: $expected RETURNED: $returned"
            }
        }
        return $rval
    }
    -result {}
    -cleanup {dropAll dbCompare}
}
#DVT: 636730
test tcl_unit_processModifyColumn {Unit test for processModifyColumn proc} {
    -setup {}
    -body {
        set result ""
        source $arrayInputOutputFile
        updateInfo MODEL_FILES_DIRECTORY $MODEL_FILES_DIRECTORY
        setDefaultArray model target $modelConnection $targetConnection
        setNullResults
        addResult $type $value
        set result [processModifyColumn MODIFY.COLUMNS]
        set val [string match *[lindex $expected_result 0] [lindex $result 0]]
        if {$val != 1} {
            if {$result != $expected_result} {
                return [list INPUT: MODIFY.COLUMNS EXPECTED: $expected_result RETURNED: $result]
            }
        }
        return 0
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
# DVT 636728 - processEnableConstraint
test tcl_unit_processEnableConstraint {Unit test for processEnableConstraint} {
    -setup {}
    -body {
        set rval ""
        # set the values in model array
        updateInfo MODEL_FILES_DIRECTORY $MODEL_FILES_DIRECTORY
        setDefaultArray modelDef targetDef $modelConnection $targetConnection

        if {$processEnableConstraint != "negative"} {

            for {set i 1} {$i <=2} {incr i} {
                set result ""
                set inputVal1 [set avalue$i]
                set inputVal2 [set bvalue$i]
                set inputVal3 [set cvalue$i]
                set output [set expected_Result$i]

                # Calling proc addResult to add value and type in global array result
                addWarning $type $inputVal1
                addWarning $type $inputVal2
                addWarning $type $inputVal3

                global RESULTS
                array set RESULTS {ENABLE/VALIDATE.CONSTRAINTS {}}

                # Calling proc processEnableConstraint

                if [catch {set result [processEnableConstraint ""]} err] {
                    return "Sequence $i $type $inputVal1 $inputVal2 $inputVal3 $err\n[getResultNames]\n [getWarnings $type]"
                }
                set val [string match "*[lindex $output 0]" [lindex $result 0]]
                if {$val != 1} {
                    if {$result != $output} {
                        lappend rval "Sequence: $i Case Type: $processEnableConstraint\nINPUT 1: inputVal1\nINPUT 2: $inputVal2\nINPUT 3: $inputVal3\nEXPECTED: $output\nRETURNED: $result"
                    }
                }
                unset WARNINGS
            }
        } else {
            # Calling proc processEnableConstraint

            if [catch {set result [processEnableConstraint ""]} err] {
                if {$err != $expected_error} {
                    lappend rval "Sequence: 3 Case Type: $processEnableConstraint\nEXPECTED: $expected_error RETURNED: $err"
                }
            }
        }
        if {$rval != ""} {
            return $rval
        }
        return 0
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT: 637202
test tcl_unit_removeResult {Unit test for removeResult} {
    -setup {}
    -body {
        set rval ""
        # set the values in model array
        updateInfo MODEL_FILES_DIRECTORY $MODEL_FILES_DIRECTORY
        setDefaultArray model target $modelConnection $targetConnection
        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            set dropIndex [set drop_Index$i]
            set expectedResult [set expected_result$i]
            if {$removeResult_type == "positive"} {
                #Calling proc addResult to add value and type in Glabal array RESULT
                addResult DROP.INDEX $dropIndex
            }
            #Calling proc removeResult
            if [catch {set result [removeResult DROP.INDEX $dropIndex]} err] {
                if {$err == $expectedResult} {
                    continue
                } else {
                    lappend rval [list Sequence: $i  INPUT: Scenario Type: $removeResult_type Drop Index: $dropIndex EXPECTED: $expectedResult RETURNED: $err]
                    continue
                }
            }
            if {$RESULTS(DROP.INDEX) != $expectedResult} {
                lappend rval [list Sequence: $i  INPUT: Scenario Type: $removeResult_type Drop Index: $dropIndex EXPECTED: $expectedResult RETURNED: $RESULTS(DROP.INDEX)]
            }
        }
        return $rval
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
#DVT: 635714
test tcl_unit_outputDelta {Unit test for proc outputDelta} {
    -setup {}
    -body {
			source $TEST_HOME/$inputFile
            set err ""
            setInitialArrays
            if [catch {
                getConnectionSetup modelDef $modelConnection $MODEL_FILES_DIRECTORY
                getConnectionSetup targetDef $modelConnection $MODEL_FILES_DIRECTORY
                getMetaDataSource modelDef targetDef
            } er1] {
                lappend err $er1
            }
            array set modelDef [getMetaData "$MODEL_FILES_DIRECTORY/$modelConnection" all MODELFILES]
            set types $modelDef(DEF.TYPES)
            foreach type $types {
                getModel modelDef [file join $modelDef(ModDir) $type]
            }
            setDefaultMeta modelDef

            if {$xmlVerNum == "03010100" && $condition == "le"} {
            # Scenario 1: Print delta for valid differences
                set channel [getReportFile tool "" validDelta.txt]
                updateInfo default_channel $channel
                setNullResults
                array set RESULTS [array get $sampleRes1]
                outputDelta $channel
                close $channel
                if {[compare2Files "validDelta.txt" $sampleFile1] != 0} {
                    set fptr [open $sampleFile1 r]
                    set fContent [read $fptr]
                    close $fptr
                    lappend err "SEQUENCE:1  INPUT:[getResults *]  EXPECTED:$fContent   RETURNED:[getResults *]"
                }
                catch {file delete -force "validDelta.txt"}

                #Scenario 2: Print delta for no differences
                set channel [getReportFile tool "" noDelta.txt]
                updateInfo default_channel $channel
                setNullResults
                array set RESULTS [array get $sampleRes2]
                outputDelta $channel
                close $channel
                if {[compare2Files "noDelta.txt" $sampleFile2] != 0} {
                    set fptr [open $sampleFile2 r]
                    set fContent [read $fptr]
                    close $fptr
                    lappend err "SEQUENCE:2  INPUT:[getResults *]  EXPECTED:$fContent  RETURNED:[getResults *]"
                }

                catch {file delete -force "noDelta.txt"}
                return $err

            } elseif {$xmlVerNum >= 03020000 && $condition == "ge"} {

                    #Scenario 1: Print delta for no differences
                        set channel [getReportFile tool "" noDelta.txt]
                        updateInfo default_channel $channel
                        setNullResults
                        array set RESULTS [array get $sampleRes1]
                        outputDelta $channel
                        close $channel
                        if {[compare2Files "noDelta.txt" $sampleFile1] != 0} {
                            set fptr [open $sampleFile1 r]
                            set fContent [read $fptr]
                            close $fptr
                            lappend err "SEQUENCE:1  INPUT:[getResults *]  EXPECTED:$fContent  RETURNED:[getResults *]"
                        }
                        catch {file delete -force "noDelta.txt"}
                        return $err

            } else { lappend retVal "Skipped: $xmlVerNum" }
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
#DVT: 637208
test tcl_unit_processRECREATE_INDEX_DROP {Unit test for processRECREATE_INDEX_DROP} {
    -setup {}
    -body {
        set rval ""
        # set the values in model array
        updateInfo MODEL_FILES_DIRECTORY $MODEL_FILES_DIRECTORY
        setDefaultArray model target $modelConnection $targetConnection
        if {$caseType != "Negative"} {
            for {set i 1} {$i <= $no_of_scenarios} {incr i} {
                set inputRecreateIndex [set recreate_Index$i]
                regsub -all {[\t ]} [set expected_result$i] "" output

                #Calling proc addResult to add value and type in Glabal array RESULT
                addResult RECREATE.INDEXS $inputRecreateIndex
                global WARNINGS
                array set WARNINGS {RECREATE.INDEXS {}}
                #Calling proc processRECREATE_INDEX_DROP
                if [catch {set result [processRECREATE_INDEX_DROP Results]} err] {
                    return $err
                }
                regsub -all {[\t ]} $result "" result
                if {$result != $output} {
                    lappend rval "Sequence: $i Case Type: $caseType\nEXPECTED: $output\nRETURNED: $result"
                }
                unset RESULTS
            }
        }   else {
                global WARNINGS
                array set WARNINGS {RECREATE.INDEXS {}}
                #Calling proc processRECREATE_INDEX_DROP
                if [catch {set result [processRECREATE_INDEX_DROP Results]} err] {
                    if {$err != $expected_error} {
                        lappend rval "Sequence: 1 Case Type: $caseType\nEXPECTED: $expected_error\nRETURNED: $err"
                    }
                }
            }
        return $rval
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
# DVT 637203 - processValidateConstraint
test tcl_unit_processValidateConstraint {Unit test for processValidateConstraint} {
    -setup {}
    -body {
        set rval ""
        # set the values in model array
        updateInfo MODEL_FILES_DIRECTORY $MODEL_FILES_DIRECTORY
        setDefaultArray modelDef targetDef $modelConnection $targetConnection
        if {$processValidateConstraint != "negative"} {
         for {set i 1} {$i <= 2} {incr i} {
                set inputVal1 [set avalue$i]
                set inputVal2 [set bvalue$i]
                set inputVal3 [set cvalue$i]
                set output [set expected_Result$i]

                # Calling proc addResult to add value and type in global array result
                addWarning $type $inputVal1
                addWarning $type $inputVal2
                addWarning $type $inputVal3

                global RESULTS
                array set RESULTS {VALIDATE.CONSTRAINTS {}}

                # Calling proc processValidateConstraint

                if [catch {set result [processValidateConstraint ""]} err] {
                puts "result: $result"
                return $err
                }
                if {$result != $output} {
                lappend rval "Sequence: $i INPUT 1: $inputVal1\nINPUT 2: $inputVal2\nINPUT 3: $inputVal3\nEXPECTED: $output\nRETURNED: $result"
                }
                unset WARNINGS
            }
        } else {
                # Calling proc processValidateConstraint

                if [catch {set result [processValidateConstraint ""]} err] {
                    if {$err != $expected_error} {
                        lappend rval "Sequence: 3 EXPECTED: $expected_error RETURNED: $err"
                    }
                }
            }
            if {$rval != ""} {
                return $rval
            }
        return 0
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT: 637205
test tcl_unit_setInitialNulls {Unit test for setInitialNulls proc} {
    -setup {}
    -body {
        global modelDef
        global targetDef
        set reval ""
        source $arrayInputOutputFile

        if [catch {getConnectionSetup modelDef $modelConnection $MODEL_FILES_DIRECTORY} err] {
            return $err
        }
        if [catch {getConnectionSetup targetDef $modelConnection $MODEL_FILES_DIRECTORY} err] {
            return $err
        }
        if [catch {getMetaDataSource modelDef targetDef} err] {
            return $err
        }

        array set modelDef [getMetaData "$MODEL_FILES_DIRECTORY/$modelConnection" $utcfile $sourceType]
        array set modelDef {$utcfile.header {} $utcfile.key {} $utcfile.data {}}

        setInitialNulls modelDef

        foreach type $modelDef(DEF.TYPES) {
            if { $modelDef($type.header) != "" || $modelDef($type.key) != "" || $modelDef($type.data) != "" } {
                return [list INPUT: "" EXPECTED: modelDef(type.header)="", modelDef(type.key)="", modelDef(type.data)="" RETURNED: modelDef(type.header)=$modelDef($type.key), modelDef(type.key)=$modelDef($type.key), $modelDef($type.data)=$modelDef($type.data)]
            }
        }
        return 0
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT: 637316
test tcl_unit_setNullResults {Unit test for setNullResults} {
    -setup {}
    -body {
        set rval ""
        source $TEST_HOME/testdata/Array_Input_Output.txt
        #Calling proc setNullResults
        if [catch {set result [setNullResults]} err] {
            return $err
        }
        set WARNING_Diff [cmpArray expected_WARNINGS WARNINGS]
        set RESULTS_Diff [cmpArray expected_RESULTS RESULTS]
        if {$WARNING_Diff != "" && $RESULTS_Diff != ""} {
            lappend rval "Sequence: 1\nEXPECTED WARNING DIFF: \nACTUAL WARNING DIFF: $WARNING_Diff\nEXPECTED RESULT DIFF: \nACTUAL RESULT DIFF: $RESULTS_Diff"
        }
        return $rval
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
# DVT 637209 - processRECREATE_CONSTRAINT_DROP
test tcl_unit_processRECREATE_CONSTRAINT_DROP {Unit test for processRECREATE_CONSTRAINT_DROP} {
    -setup {}
    -body {

        # set the values in model array
        updateInfo MODEL_FILES_DIRECTORY $MODEL_FILES_DIRECTORY
        setDefaultArray modelDef targetDef $modelConnection $targetConnection


        set rval ""
        if {$processRecreateConsDrop != "negative"} {
            for {set i 1} {$i <= 2} {incr i} {

                set inputVal [set value$i]
                set output [set expected_Result$i]

                # Calling proc addResult to add value and type in global array result
                addResult $type $inputVal

                global WARNINGS
                array set WARNINGS {RECREATE.CONSTRAINTS {}}

                # Calling proc processRECREATE_CONSTRAINT_DROP

                if [catch {set result [processRECREATE_CONSTRAINT_DROP ""]} err] {
                    return $err
                }
                if {$result != $output} {
                    lappend rval "Sequence: $i Case Type: $processRecreateConsDrop\nINPUT: $inputVal\nEXPECTED: $output\nRETURNED: $result"
                }
                unset RESULTS
            }
        }   else {
            # Calling proc processRECREATE_CONSTRAINT_DROP

                if [catch {set result [processRECREATE_CONSTRAINT_DROP ""]} err] {
                    if {$err != $expected_error} {
                        lappend rval "Sequence: 3 Case Type: $processRecreateConsDrop\nEXPECTED: $expected_error RETURNED: $err"
                    }
                }
            }
        if {$rval != ""} {
            return $rval
        }
        return 0
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}

#DVT: 636724
test tcl_unit_processDrop0 {Unit test for proc processDrop0} {
    -setup {}
    -body {
        set err ""
        source $inputFile
        # Scenario 1: Valid values in RESULTS
        # Scenario 2: Null values in RESULTS
        # Scenario 3: Valid values in WARNINGS
        # Scenario 4: Null values in WARNINGS
        # Scenario 5: Valid values in both RESULTS & WARNINGS
        for {set i 1} {$i <= $totalCases} {incr i} {
            setNullResults
            set resultsArr [set sampleRes$i]
            set warningsArr [set sampleWar$i]
            set listName [set listName$i]
            set type [set type$i]
            set returned [set samplePD$i]
            array set RESULTS [array get $resultsArr]
            array set WARNINGS [array get $warningsArr]
            set result [processDrop0 $listName $type]
            set val [string match "*[lindex $returned 0]" [lindex $result 0]]
            if {$val != 1} {
                lappend err [list SEQUENCE:$i "INPUT: Results-[getResults *] Warnings-[getWarnings *] listName-$listName type-$type" EXPECTED:$returned RETURNED:[processDrop0 $listName $type]]
            }
            unset RESULTS WARNINGS
        }
        return $err
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
#DVT: 636726
test tcl_unit_processDrop1 {Unit test for proc processDrop1} {
    -setup {}
    -body {
        set err ""
        source $inputFile
        # Scenario 1: Valid values in RESULTS
        # Scenario 2: Null values in RESULTS
        # Scenario 3: Valid values in WARNINGS
        # Scenario 4: Null values in WARNINGS
        # Scenario 5: Valid values in both RESULTS & WARNINGS
        for {set i 1} {$i <= $totalCases} {incr i} {
            setNullResults
            set resultsArr [set sampleRes$i]
            set warningsArr [set sampleWar$i]
            set listName [set listName$i]
            set type [set type$i]
            set returned [set samplePD$i]
            array set RESULTS [array get $resultsArr]
            array set WARNINGS [array get $warningsArr]
            set result [processDrop1 $listName $type]
            set val [string match "*[lindex $returned 0]" [lindex $result 0]]
            if {$val != 1} {
                lappend err [list SEQUENCE:$i "INPUT: Results-[getResults *] Warnings-[getWarnings *] listName-$listName type-$type" EXPECTED:$returned RETURNED:[processDrop1 $listName $type]]
            }
            unset RESULTS WARNINGS
        }
        return $err
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
#DVT: 636727
test tcl_unit_processDrop2 {Unit test for proc processDrop2} {
    -setup {}
    -body {
        set err ""
        source $inputFile
        # Scenario 1: Valid values in RESULTS
        # Scenario 2: Null values in RESULTS
        # Scenario 3: Valid values in WARNINGS
        # Scenario 4: Null values in WARNINGS
        # Scenario 5: Valid values in both RESULTS & WARNINGS
        for {set i 1} {$i <= $totalCases} {incr i} {
            setNullResults
            set resultsArr [set sampleRes$i]
            set warningsArr [set sampleWar$i]
            set listName [set listName$i]
            set type [set type$i]
            set returned [set samplePD$i]
            array set RESULTS [array get $resultsArr]
            array set WARNINGS [array get $warningsArr]
            set result [processDrop2 $listName $type]
            set val [string match "*[lindex $returned 0]" [lindex $result 0]]
            if {$val != 1} {
                lappend err [list SEQUENCE:$i "INPUT: Results-[getResults *] Warnings-[getWarnings *] listName-$listName type-$type" EXPECTED:$returned RETURNED:[processDrop2 $listName $type]]
            }
            unset RESULTS WARNINGS
        }
        return $err
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
#DVT: 637514
test tcl_unit_setMetaDataSource {Unit test for setMetaDataSource} {
    -setup {}
    -body {
        set rval ""
        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            set inputType [set type$i]
            set output [set expected_Result$i]


            #Calling proc setMetaDataSource
            if [catch {set result [setMetaDataSource model $inputType]} err] {
                return $err
            }
            if {$DBS_INFO(dbCompare.model.metaType) != $output} {
                lappend rval "Sequence: $i CaseType: $casetype\nEXPECTED: $output\nRETURNED: $result"
            }
        }
        return $rval
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
# DVT 635402 - RE AT test for logit
test tcl_unit_logit {Unit test for logit} {
    -setup {}
    -body {
            set rval ""
            # Checking the existance of file name starting with DEFAULT_LOG
            set checkfile [glob -type f $logFileName*]
            # Deletion of all existing default log files
            foreach file $checkfile {
                file delete -force $file
            }

            # CALLING PROC
            logit $stringData

            set checkfile [glob -type f $logFileName*]
            set checkfile1 [file exist $checkfile]

            if {$checkfile1 == 1} {
                set fp [open $checkfile r]
                set file_data [read $fp]
                set result [string trim $file_data]
                close $fp

                if {$result != $stringData} {
                lappend rval "EXPECTED: $stringData\nRETURNED: $result"
                } else {return 0}
        } else {return 1}
        if {$rval != ""} {
            return $rval
        }
        return 0
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT: 637510
test tcl_unit_trimListItems {Unit test for trimListItems proc} {
    -setup {}
    -body {
        set result [trimListItems $myList]

        if {$result == $expected_result} {
            return 0
        } else {
            return [list INPUT: $myList EXPECTED: $expected_result RETURNED: $result]
        }
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT 637201:test for processRename
test tcl_unit_processRename {Unit test for processRename proc} {
    -setup {}
    -body {

        set retval ""
        set result ""

        for {set i 1} {$i <= $no_of_scenarios} {incr i} {

                set inpVar [set type$i]
                set outVar [set expectedresult$i]

                addResult RENAME.$inpVar\S $inpVar
                addWarning RENAME.$inpVar\S $inpVar

                set result [processRename $list1 $inpVar]

                set val [string match "*[lindex $outVar 0]" [lindex $result 0]]
                if {$val != 1} {
                 lappend retval [list Sequence: $i INPUT: List is: $inpVar EXPECTED: $outVar RETURNED: $result]
                }
                unset inpVar
                unset RESULTS
                unset WARNINGS
        }

        return $retval

    }
    -result { }
    -cleanup {dropAll dbCompare}
}
#DVT: 635801
test tcl_unit_p_getSchemaProcedureData1.1 {Unit test for p_getSchemaProcedureData proc} {
    -setup {}
    -body {
        set retval 0
        # POSITIVE CASE
        updateInfo MODEL_FILES_DIRECTORY $MODEL_FILES_DIRECTORY
        setDefaultArray model target $modelConnection $targetConnection
        if { [catch {getLogonHandle $targetConnection} dbh ] }  {
             return 1
        }
        set result [p_getSchemaProcedureData $targetConnection target]

        if {$result != ""} {
            lappend retval [list INPUT: List is: [array get target] EXPECTED: RETURNED: $result]
        }
        return $retval
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT: 635801
test tcl_unit_p_getSchemaProcedureData1.2 {Unit test for p_getSchemaProcedureData proc} {
    -setup {}
    -body {
         set retval 0
         updateInfo MODEL_FILES_DIRECTORY $MODEL_FILES_DIRECTORY
         setDefaultArray model target $modelConnection $targetConnection

        if { [catch {getLogonHandle $targetConnection} dbh ] }  {
             return 1
        }
        set result [p_getSchemaProcedureData $targetConnection target $tables]

        if {$result != ""} {
            lappend retval [list INPUT: List is: $tables [array get target]  EXPECTED: RETURNED: $result]
        }
        return $retval
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT: 635801
test tcl_unit_p_getSchemaProcedureData1.3 {Unit test for p_getSchemaProcedureData proc} {
    -setup {}
    -body {
        set retval 0
        updateInfo MODEL_FILES_DIRECTORY $MODEL_FILES_DIRECTORY
        setDefaultArray model target $modelConnection $targetConnection


        set target(DEF.USER_PROCEDURES.data) "USER_SOURCE.TEXT"

        if { [catch {getLogonHandle $targetConnection} dbh ] }  {
             return 1
        }
        set result [p_getSchemaProcedureData $targetConnection target]

        if {$result != ""} {
            lappend retval [list INPUT: List is:[array get target]  EXPECTED: RETURNED: $result]
        }
        return $retval
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT: 635802
test tcl_unit_p_getSchemaSequenceData {Unit test for p_getSchemaSequenceData proc} {
    -setup {}
    -body {
          source $sampleInput
          updateInfo MODEL_FILES_DIRECTORY $MODEL_FILES_DIRECTORY
          setDefaultArray modelDef targetDef $modelConnection $targetConnection
          set result ""
          set tc $p_getSchemaSequence_testcount

          if {$p_getSchemaSequence_name != "negative"} {
            for {set i 1} {$i <= $tc} {incr i} {
              set inpVar [set tableName$i]
              set outVar1 [set p_getSchemaSequenceData$i]
              set outVar2 [set p_getSchemaSequenceKey$i]
              set outVar3 [set p_getSchemaSequenceHeader$i]
              set res [p_getSchemaSequenceData $targetConnection modelDef $inpVar]
              if { ($modelDef(USER_SEQUENCES.data) != $outVar1) &&
               ($modelDef(USER_SEQUENCES.header) != $outVar3) &&
               ($modelDef(USER_SEQUENCES.key) != $outVar2) } {
                  lappend result [list Sequence $i INPUT: $inpVar EXPECTED DATA: $outVar1 RETURNED DATA: ($modelDef(USER_SEQUENCES.data) EXPECTED KEY: $outVar2 RETURNED KEY: ($modelDef(USER_SEQUENCES.key) EXPECTED HEADER: $outVar3 RETURNED HEADER: ($modelDef(USER_SEQUENCES.header)]
              }
              set modelDef(USER_SEQUENCES.data) ""
              set modelDef(USER_SEQUENCES.header) ""
              set modelDef(USER_SEQUENCES.key) ""
            }
          }
          if {$result == ""} {
              return 0
          } else {
             return $result
          }
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT: 635713
test tcl_unit_MoveOutput {Unit test for proc MoveOutput} {
    -setup {}
    -body {
        set err ""
        # Scenario 1: Happy case
        setInfo suppressOutput SILENT 
        set testdir $TCL_UNIT_TEST_WORKING_DIR/$testdir
        catch [file delete -force $testdir]
        file mkdir $testdir
        set samplefile $TEST_HOME/testdata/$samplefile
        set testingBase $testdir/$testingTempDir1
        file mkdir $testingBase
        file copy -force [glob $samplefile] $testdir/1Sample1.txt
        file copy -force [glob $samplefile] $testdir/1Sample2.txt
        file copy -force [glob $samplefile] $testdir/1Sample3.txt
        MoveOutput $testdir/1Sample* $testingBase
        if {![file exists $testingBase/1Sample1.txt] || ![file exists $testingBase/1Sample2.txt] || ![file exists $testingBase/1Sample3.txt]} {
            lappend err [list SEQUENCE:1 "INPUT: Dir-$testingBase" "EXPECTED: Files 1Sample1.txt 1Sample2.txt 1Sample3.txt should get moved to $testingBase" "RETURNED:File not present in $testingTempDir1"]
        } 
        catch [file delete -force $testdir] 
        
        # Scenario 2: Directory already exists
        file mkdir $testdir
        file copy $samplefile $testdir
        file copy -force [glob $samplefile] $testdir/1Sample1.txt
        file copy -force [glob $samplefile] $testdir/1Sample2.txt
        file copy -force [glob $samplefile] $testdir/1Sample3.txt
        set testingBase $testdir/$testingTempDir1
        file mkdir $testingBase
        MoveOutput $testdir/1Sample* $testingBase
        if {![file exists $testingBase/1Sample1.txt] || ![file exists $testingBase/1Sample2.txt] || ![file exists $testingBase/1Sample3.txt]} {
            lappend err [list SEQUENCE:2 "INPUT: Dir-$testingBase" "EXPECTED: Files 1Sample1.txt 1Sample2.txt 1Sample3.txt should get moved to $testingBase" "RETURNED:File not present in $testingBase"]
        }
        catch [file delete -force $testdir]
        # Scenario 3: Directory's name has spaces

        file mkdir $testdir
        set testingBase $testdir/$testingTempDir3
        file mkdir $testingBase
        file copy -force [glob $samplefile] $testdir/1Sample1.txt
        file copy -force [glob $samplefile] $testdir/1Sample2.txt
        file copy -force [glob $samplefile] $testdir/1Sample3.txt
        MoveOutput $testdir/1Sample* $testingBase
        if {![file exists $testingBase/1Sample1.txt] || ![file exists $testingBase/1Sample2.txt] || ![file exists $testingBase/1Sample3.txt]} {
            lappend err [list SEQUENCE:3 "INPUT: Dir-$testingBase" "EXPECTED: Files 1Sample1.txt 1Sample2.txt 1Sample3.txt should get moved to $testingBase" "RETURNED:File not present in $testingBase"]
        }
        catch [file delete -force $testdir]

        # Scenario 4: File already exists in the target destination
        set testingBase $testdir/$testingTempDir1
        file mkdir $testdir
        file copy $samplefile $testdir/Sample1.txt
        file mkdir $testingBase
        file copy -force [glob $samplefile] $testingBase/Sample1.txt
        MoveOutput $testdir/Sample* $testingBase
        if {![file exists $testingBase/Sample1.txt]} {
            lappend err [list SEQUENCE:4 "INPUT: Dir-$testingBase" "EXPECTED: Files should get moved to $testingBase" "RETURNED: File not present in $testingBase"]
        }

        # catch [file delete -force $testdir]

        # Scenario 5: File's name has spaces
        # set home [pwd]
        # cd testdata
        # catch [file delete -force $testdir] 
        # file mkdir $testdir
        # file copy $samplefile $testdir
        # cd $testdir
        # file copy -force [glob $samplefile] "$TCL_UNIT_TEST_WORKING_DIR/1\ Sample\ 1.txt"
        # MoveOutput 1*Sample* $testingTempDir1
        # if {![file exists $testingTempDir1/1\ Sample\ 1.txt]} {
            # lappend err [list SEQUENCE:5 "INPUT: Dir-$testingTempDir1" "EXPECTED: File 1 Sample 1.txt should get moved to $testingTempDir1" "RETURNED: File not present in $testingTempDir1"]
        # }
        # set logFile [getInfo default_channel]
        # unsetInfo default_channel
        # close $logFile
        # cd $home 
        # catch [file delete -force $TCL_UNIT_TEST_WORKING_DIR/$testdir]

        # Scenario 6: Create multiple directories at once
        # set home [pwd]
        # cd testdata
        # catch [file delete -force $testdir] 
        # file mkdir $testdir
        # file copy $samplefile $testdir
        # cd $testdir
        # file copy -force [glob $samplefile] $TCL_UNIT_TEST_WORKING_DIR/1Sample1.txt
        # MoveOutput 1Sample* $testingTempDir6
        # if {![file exists $testingTempDir6/1Sample1.txt]} {
            # lappend err [list SEQUENCE:6 "INPUT: Dir-$testingTempDir6" "EXPECTED: File 1Sample1.txt should get moved to $testingTempDir6" "RETURNED: File not present in $testingTempDir6"]
        # }
        # set logFile [getInfo default_channel]
        # unsetInfo default_channel
        # close $logFile
        # cd $home 
        # catch [file delete -force $TCL_UNIT_TEST_WORKING_DIR$testdir]
        catch [file delete -force $testdir]
        
        # Scenario 6: check lst files in working directory
        file mkdir $testdir
        set testingBase $testdir/$testingTempDir1
        file mkdir $testingBase
        set lstfileList [split $asLstFile " "]
        foreach lstfile $lstfileList {
            set out [open "$testdir/$lstfile" w]
            close $out
        }
        MoveOutput "$testdir/*.lst" $testingBase
        if {![file exists $testingBase/cert0000.lst] || ![file exists $testingBase/LANDA_PACKAGE_UPDATE.lst] || ![file exists $testingBase/CTXTextStorage.lst]|| ![file exists $testingBase/udw_dlg_association_fix.lst] || ![file exists $testingBase/LANDA_CONVERSION_SOURCE.lst]|| ![file exists $testingBase/CR03000000.lst] || ![file exists $testingBase/FDD.lst]} {
            lappend err [list SEQUENCE:6 "EXPECTED: Files cert0000.lst LANDA_PACKAGE_UPDATE.lst CTXTextStorage.lst udw_dlg_association_fix.lst LANDA_CONVERSION_SOURCE.lst CR03000000.lst FDD.lst should get moved to $testingBase" "RETURNED:File not present in $testingBase"]
        }
        catch [file delete -force $testdir]
        return $err
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
#DVT: 637799
test tcl_unit_splat {Unit test for splat} {
    -setup {}
    -body {
        set rval ""

        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            set inputStr [set str$i]
            set inputSep [set sep$i]
            set output [set expected_Result$i]

            #Calling proc splat
            if [catch {set result [splat $inputStr $inputSep]} err] {
            return $err
            }
            if {$result != $output} {
                lappend rval "Sequence: $i\nEXPECTED: $output\nRETURNED: $result"
            }
        unset result
        }
        return $rval
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
# DVT 637796 - RA AT test for setDefaultMeta
test tcl_unit_setDefaultMeta {Unit test for setDefaultMeta} {
    -setup {}
    -body {
        set rval ""
        source $arrayFile
        setDefaultMeta defaultMetaArray

        set result [getInfo dbCompare.defaultMetaArray]

        if {$result != $Expected_Default_List} {
            lappend rval "Sequence: 1 EXPECTED: $Expected_Default_List RETURNED: $result"
        }
        if {$rval != ""} {
            return $rval
        }
        return 0
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}

#638535 Unit test for setDefaultMetaByList

test tcl_unit_setDefaultMetaByList {Unit test for setDefaultMetaByList} {
    -setup {}
    -body {

        set result ""

        for {set i 1} {$i <= 2} {incr i} {

            set inpVar [set list$i]
            set outVar [set expected_result$i]

            setDefaultMetaByList $inpVar

            set result [getInfo dbCompare.defaultMetaArray]

            if {$result != $outVar} {
             lappend result [list Sequence: $i INPUT: List is: $inpVar EXPECTED: $outVar RETURNED: $result]
            }
        }
        if {$result == ""} {
            return 0
          } else {
             return $result
        }
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}

#DVT: 637793
test tcl_unit_unsetInfo {Unit test for proc unsetInfo} {
    -setup {}
    -body {
        set err ""
        # Scenario 1: Proc called with no inputs, check that DBS_INFO still has the default data
        unsetInfo $inputVal1
        if {[array names DBS_INFO] == $outputVal1} {
            lappend err "SEQUENCE:1 INPUT:None  EXPECTED:DBS_INFO with default data  RETURNED:[array names DBS_INFO]"
        }
        unsetInfo all

        # Scenario 2: Proc called with a valid name
        setInfo $inputName2 $inputVal2
        unsetInfo $inputName2
        if {[array names DBS_INFO $inputName2] != $outputVal2} {
            lappend err "SEQUENCE:2  INPUT:$inputVal2  EXPECTED:$outputVal2  RETURNED:[array names DBS_INFO $inputName2]"
        }
        unsetInfo all

        # Scenario 3: Proc called with a name that does not exist in the array
        array set InfoBefore [array get DBS_INFO]
        unsetInfo $inputName3
        array set InfoAfter [array get DBS_INFO]
        if {[cmpArray InfoBefore InfoAfter] != $outputVal3} {
            lappend err "SEQUENCE:3  INPUT:$inputName3  EXPECTED:  RETURNED:[cmpArray InfoBefore InfoAfter]"
        }
        unset InfoBefore InfoAfter

        # Scenario 4: Proc called with an expression that matches multiple names in the array
        setInfo $inputName41 $inputVal41
        setInfo $inputName42 $inputVal42
        unsetInfo $inputName4
        if {[array names DBS_INFO $inputName4] !=$outputVal4} {
            lappend err "SEQUENCE:4  INPUT:$inputName4  EXPECTED:$outputVal4  RETURNED:[array names DBS_INFO $inputName4]"
        }
        unsetInfo all

        # Scenario 5: Proc called with input "all"
        array set DBS_INFO [array get $inputName51]
        unsetInfo $inputName5
        if {[array names DBS_INFO] != $outputVal5} {
            lappend err "SEQUENCE:5  EXPECTED:$outputVal5  RETURNED:[array names DBS_INFO]"
        }
        setInfo abc 123

        return $err
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
# DVT 637794 - RE AT test for proc putt
test tcl_unit_putt {Unit test for putt} {
    -setup {}
    -body {
        set retval ""
        set result ""
        set filename $TCL_UNIT_TEST_WORKING_DIR/$filename
        set fp [open $filename w+]

        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            putt $fp $inputstring

            set readfp [open $filename r]
            set file_data [read $readfp]
            set result [string trim $file_data]

            close $fp
            close $readfp

            file delete -force $filename

            if {$result != $expected_result} {
                lappend retval [list Sequence: $i INPUT: List is: $inputstring EXPECTED: $expected_result RETURNED: $result]
            }
        }
        return $retval
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
#DVT: 637902
test tcl_unit_setInitialArrays {Unit test for setInitialArrays proc} {
    -setup {}
    -body {

        setInitialArrays

        if { [array size modelDef] == 0 && [array size targetDef] == 0 && [array size RESULTS] == 0  && [array size INDICES] == 3 && $INDICES(header) == 0 && $INDICES(key) == 1 && $INDICES(data) == 2} {
            return 0
        }

        return [list INPUT: "" EXPECTED: $INDICES(header)=0, $INDICES(key)=1, $INDICES(data)=2 RETURNED: INDICES(header)=$INDICES(header), INDICES(key)=$INDICES(key), INDICES(data)=INDICES(data)]
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
# DVT 637795 - RE AT test for proc setDebugOn
test tcl_unit_setDebugOn_1.1 {Unit test for setDebugOn} {
    -setup {}
    -body {

            set result ""
            set retval ""
            # Checking the existance of file name
            set checkfile ""
            set checkfile [glob -nocomplain -type f *.DEBUG.*.out]

            # Deletion of all existing default log files

            if {$checkfile != ""} {
                foreach file $checkfile {
                    file delete -force $file
                }
            }

            #Calling Proc

            setDebugOn $filename

            set FE  [glob -nocomplain -type f *.DEBUG.*.out]
            set result [file exists $FE]

            if {$result != 1} {
                lappend retval [list TYPE: $type INPUT:$filename EXPECTED: 1 RETURNED: $result]
            }
            #Deleting file
            file delete -force $filename
            return $retval
        }
    -result {  }
    -cleanup {dropAll dbCompare}
}
# DVT 637795 - RE AT test for proc setDebugOn
test tcl_unit_setDebugOn_1.2 {Unit test for setDebugOn} {
    -setup {}
    -body {

            set retval ""
            set result ""
            # Checking the existance of file name

            set checkfile ""
            set checkfile [glob -nocomplain -type f *.DEBUG.*.out]

            # Deletion of all existing default log files

            if {$checkfile != ""} {
                foreach file $checkfile {
                    file delete -force $file
                }
            }

            setInfo DEBUG_CHANNEL $channel

            #Calling Proc

            setDebugOn " "

            set FE  [glob -nocomplain -type f *.DEBUG.*.out]
            set result [file exists $FE]

            if {$result != 0} {
                lappend retval [list TYPE: $type INPUT:"" EXPECTED: 0 RETURNED: $result]
            }

            return $retval
        }
    -result {   }
    -cleanup {dropAll dbCompare}
}

#DVT: 637900
test tcl_unit_setlog {Unit test for proc setlog} {
    -setup {}
    -body {
        set err ""
        set fileName $TCL_UNIT_TEST_WORKING_DIR/$fileName
        # Scenario 1: Proc called with action=ON & a file name
        if [catch {set retVal [setlog ON $fileName]} er1] {
            lappend err [list SEQUENCE:1 "INPUT:Action-ON logfile-$fileName" EXPECTED:NULL "RETURNED:Error-$er1"]
        } else {
            if {$retVal == "" || $retVal == -1} {
                lappend err [list SEQUENCE:1 "INPUT:Action-ON logfile-$fileName" EXPECTED:NULL "RETURNED:Error-$retVal"]
            } else {
                catch {close $retVal}
            }
        }
        catch [file delete -force $fileName]

        # Scenario 2: Proc called with action=OFF & a file handle
        if [catch {set fHandle [open $fileName w]} er1] {
            lappend err [list SEQUENCE:2 "INPUT:Action-OFF logfile-$fileName" EXPECTED:NULL "RETURNED:Error-$er1"]
        } else {
            if [catch {set retVal [setlog OFF $fHandle]} er1] {
                lappend err [list SEQUENCE:2 "INPUT:Action-OFF logfile-$fileName" EXPECTED:NULL "RETURNED:Error-$er1"]
            } else {
                # Checking if the file is still open for writing
                if [catch {puts $fHandle trialText} er1] {
                    if {$er1 != "can not find channel named \"$fHandle\""} {
                        [list SEQUENCE:2 "INPUT:Action-OFF logfile-$fileName" "EXPECTED:can not find channel named \"$fHandle\"" RETURNED:Error-$er1]
                    }
                } else {
                    lappend $err [list SEQUENCE:2 "INPUT:Action-OFF logfile-$fileName" "EXPECTED:File should be closed" "RETURNED:File is still open for writing"]
                }
            }
            catch {close $fHandle}
        }
        catch [file delete -force $fileName]

        # Scenario 3: Proc called with action=OFF & no file handle (usage of defaultChannel)
        if [catch {set defFile [open $fileName w]} er1] {
            lappend err [list SEQUENCE:3 "INPUT:Action-OFF logfile-\"\"" EXPECTED:NULL "RETURNED:Error-$er1"]
        } else {
            setInfo defaultChannel $defFile
            if [catch {setlog OFF ""} er1] {
                lappend err [list SEQUENCE:3 "INPUT:Action-OFF logfile-\"\"" EXPECTED:NULL "RETURNED:Error-$er1"]
            } else {
                # Checking if the file is still open for writing
                if [catch {puts $defFile trialText} er1] {
                    if {$er1 != "can not find channel named \"$defFile\""} {
                        lappend $err [list SEQUENCE:3 "INPUT:Action-OFF logfile-\"\"" "EXPECTED:can not find channel named \"$defFile\"" RETURNED:Error-$er1]
                    }
                } else {
                    lappend $err lappend $err [list SEQUENCE:3 "INPUT:Action-OFF logfile-\"\"" "EXPECTED:File should be closed" "RETURNED:File is still open for writing"]
                }
            }
            unsetInfo defaultChannel
            catch {close $defFile}
        }
        catch [file delete -force $fileName]

        # Scenario 4: Proc called with action=APPEND & a file name
        if [catch {set retVal [setlog APPEND $fileName]} er1] {
            lappend err [list SEQUENCE:4 "INPUT:Action-APPEND logfile-$fileName" EXPECTED:Null "RETURNED:Error-$er1"]
        } else {
            if {$retVal == "" || $retVal == -1} {
                lappend err [list SEQUENCE:4 "INPUT:Action-APPEND logfile-$fileName" EXPECTED:Null RETURNED:$retVal]
            } else {
                catch {close $retVal}
            }
        }
        catch [file delete -force $fileName]

        # Scenario 5: Proc called with invalid value for both action & file name
        if [catch {set retVal [setlog "" $fileName]} er1] {
            lappend err [list SEQUENCE:5 "INPUT:Action-\"\" logfile-$fileName" EXPECTED:-1 "RETURNED:Error-$er1"]
        } else {
            if {$retVal != -1} {
                lappend err [list SEQUENCE:5 "INPUT:Action-\"\" logfile-$fileName" EXPECTED:-1 RETURNED:$retVal]
            }
            catch {close $retVal}
        }
        catch [file delete -force $fileName]

        # Scenario 6: Proc called while INFO suppressOutput is set to SILENT, action = ""
        setInfo suppressOutput SILENT
        if [catch {set retVal [setlog "" $fileName]} er1] {
            lappend err [list SEQUENCE:6 "INPUT:Action-\"\" logfile-$fileName" EXPECTED:NULL "RETURNED:Error-$er1"]
        } else {
            if {$retVal != "" && [file exists $fileName]} {
                lappend err [list SEQUENCE:6 "INPUT:Action-\"\" logfile-$fileName" "EXPECTED:Return should be \"\" and $fileName should not exist" RETURNED:$retVal]
            }
            catch {close $retVal}
        }
        unsetInfo suppressOutput
        catch [file delete -force $fileName]

        # Scenario 7: Proc called with action="oN" (different case) & a file name
        if [catch {set retVal [setlog oN $fileName]} er1] {
            lappend err [list SEQUENCE:7 "INPUT:Action-oN logfile-$fileName" EXPECTED:NULL "RETURNED:Error-$er1"]
        } else {
            if {$retVal == "" || $retVal == -1} {
                lappend err [list SEQUENCE:7 "INPUT:Action-oN logfile-$fileName" EXPECTED:NULL "RETURNED:$retVal"]
            } else {
                catch {close $retVal}
            }
        }
        catch [file delete -force $fileName]

        # Scenario 8: Proc called while INFO suppressOutput is set to SILENT, action = ON
        setInfo suppressOutput SILENT
        if [catch {set retVal [setlog ON $fileName]} er1] {
            lappend err [list SEQUENCE:8 "INPUT:Action-oN logfile-$fileName" EXPECTED:NULL "RETURNED:Error-$er1"]
        } else {
            if {$retVal != "" || [file exists $fileName]} {
                lappend err [list SEQUENCE:8 "INPUT:Action-oN logfile-$fileName" "EXPECTED:Return should be \"\" and $fileName should not exist" "RETURNED:$retVal"]
            }
            catch {close $retVal}
        }
        unsetInfo suppressOutput
        catch [file delete -force $fileName]
        return $err
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
# DVT 637959 - RE AT test for showArrayNames
test tcl_unit_showArrayNames {Unit test for showArrayNames} {
    -setup {}
    -body {
            source $arrayFile
            set rval ""
            set result [showArrayNames defaultShowArrayNames DEF.$filter*]
            if {$result != $Expected_showArrayNames} {
                lappend rval "Sequence: 1 EXPECTED: $Expected_showArrayNames RETURNED: $result "
            }
            if {$rval != ""} {
                return $rval
            }
            return 0
        }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
#DVT: 637901
test tcl_unit_showArray {Unit test for proc showArray} {
    -setup {}
    -body {
        set err ""

        # Scenario 1: Proc called with only the array's name
        array set tempArr [set arrVals1]
        if {[showArray tempArr] != $sampleOutput1} {
            lappend err [list SEQUENCE:1 INPUT:$arrVals1 EXPECTED:$sampleOutput1 RETURNED:[showArray tempArr]]
        }
        array unset tempArr

        # Scenario 2: Proc called with filter set to some value other than *
        array set tempArr [set arrVals2]
        if {[showArray tempArr $filter2] != $sampleOutput2} {
            lappend err [list SEQUENCE:2 INPUT:$arrVals2 EXPECTED:$sampleOutput2 RETURNED:[showArray tempArr $filter2]]
        }
        array unset tempArr

        # Scenario 3: Proc called with endline set to some value
        array set tempArr [set arrVals3]
        if {[showArray tempArr $filter3 $endline3] != $sampleOutput3} {
            lappend err [list SEQUENCE:3 INPUT:$arrVals3 EXPECTED:$sampleOutput3 RETURNED:[showArray tempArr $filter3 $endline3]]
        }
        array unset tempArr

        # Scenario 4: Proc called with delim set to some value
        array set tempArr [set arrVals4]
        if {[showArray tempArr $filter4 $endline4 $delim4] != $sampleOutput4} {
            lappend err [list SEQUENCE:4 INPUT:$arrVals4 EXPECTED:$sampleOutput4 RETURNED:[showArray tempArr $filter4 $endline4 $delim4]]
        }
        array unset tempArr

        # Scenario 5: No array names exist with the provided filter
        array set tempArr [set arrVals5]
        if {[showArray tempArr $filter5 $endline4 $delim4] != $sampleOutput5} {
            lappend err [list SEQUENCE:5 INPUT:$arrVals5 EXPECTED:$sampleOutput5 RETURNED:[showArray tempArr $filter5 $endline4 $delim4]]
        }
        array unset tempArr
        return $err
    }
    -result {}
    -cleanup {dropAll dbCompare}
}
#DVT: 635400
test tcl_unit_insertSHS {Unit test for insertSHS} {
    -setup {}
    -body {
        set results ""

        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            set script_name [set scriptname$i]
            set type_val [set type$i]
            set desc_val [set desc$i]
            set status_val [set status$i]
            set new_version [set newversion$i]
            set old_version [set oldversion$i]
            if { [catch {getLogonHandle $targetConnection} dbh ] }  {
              puts "***ERROR - Cannot log onto $targetConnection"
              return "Unable to log onto database"
            }
            #Calling proc insertSHS to get schema sequence
            if [catch {set result [insertSHS $dbh $script_name $type_val $desc_val $status_val $new_version $old_version]} err] {
                return $err
            }
            set SQL_select "Select SHS_SQL_SCRIPT_NAME, SHS_TYPE, SHS_DESC, SHS_RESULTS, SHS_VERSION_NEW, SHS_VERSION_OLD, SHS_UID from SHS_SCHEMA_HISTORY into :SHS_SQL_SCRIPT_NAME, :SHS_TYPE, :SHS_DESC, :SHS_RESULTS, :SHS_VERSION_NEW, :SHS_VERSION_OLD :SHS_UID WHERE SHS_UID = $result"
            if { [catch {execsql use $dbh $SQL_select} err]} {
                return "$err"
            }
            if {$result != $SHS_UID || $SHS_SQL_SCRIPT_NAME != $script_name || $SHS_TYPE != $type_val || $SHS_RESULTS != $status_val} {
                lappend results [list Sequence:$i  Script Name: $script_name Type: $type_val Description: $desc_val Status: $status_val New Version: $new_version Old Version: $old_version EXPECTED: $result RETURNED: $SHS_SQL_SCRIPT_NAME, $SHS_TYPE, $SHS_DESC, $SHS_RESULTS, $SHS_VERSION_NEW, $SHS_VERSION_OLD, $SHS_UID]
            }
            set SQL_delete "Delete from SHS_SCHEMA_HISTORY WHERE SHS_UID = $result"
            catch {execsql use $dbh $SQL_delete} err
        }
        return $results
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
#DVT: 644164
test tcl_unit_PUE_compareCodes {Unit test for preUpgradeEval.tcl proc compareCodes} {
    -setup {}
    -body {
        set retVal ""
        for {set run 1} {$run <= $no_of_scenarios} {incr run} {
            set dbConn [set dbConn$run]
            if { [catch {getLogonHandle $dbConn} dbh] } {
                lappend retVal "Could not connect to $dbConn"
                continue
            }
            set src srcModDir$run
            set target targetModDir$run
            set res result$run

            set cc_res [compareCodes $src $target]
            if {$cc_res != $res} {
                lappend retVal $cc_res
            }
        }
        return $retVal
    }
    -result {  }
    -cleanup {dropAll dbCompare}
}
#DVT: 644167
test tcl_unit_SDG_compareCodes {Unit test for Sysdatagen.tcl} {
    -setup {}
    -body {
        set outputFileHandle [open $TCL_UNIT_TEST_WORKING_DIR/testOut.txt w]
        set retVal ""
        set outdir "SysDataGen_test"
        set update_Statement "update ACA_AUTH_CONDITION_CATEGORY set ACA_DESC = 'NULL' where ACA_DESC = 'Ambulance Certification'"
        set insert_Statement "update ACA_AUTH_CONDITION_CATEGORY set ACA_DESC = 'Ambulance Certification' where ACA_DESC = 'NULL'"
        set commit_statement "commit"

       if { [catch {getLogonHandle $dbConn} dbh] } {
               set retVal "Could not connect to $dbConn"
               return $retVal
        }

        if { [catch {execsql use $dbh $update_Statement} err] } {
                puts $outputFileHandle $update_Statement
                set retVal "Cannot execute sqlstatemnt $err"
                return $retVal
        }

         if { [catch {execsql use $dbh $commit_statement} err] } {
                puts $outputFileHandle $commit_statement
                set retVal "Cannot execute sqlstatemnt $err"
                return $retVal
        }


        if [catch {exec $MTCLSH SysDataGen.tcl $targetModDir $dbConn $outdir SILENT} output] {
            puts $outputFileHandle "ERROR: CAUGHT error... $output"
        } else {puts $outputFileHandle "SUCCESS: no errors caught"}

        set file [glob -nocomplain $outdir/sysDataDiff_*_*.txt]
        set fid [open $file r]
        set lines [split [string trim [read $fid]] \n]
        close $fid
        set startIndex [lsearch -regexp $lines Table.*Inserts.*Updates]
        set endIndex [lsearch  -regexp $lines "No Changes to .*"]

        foreach line [lrange $lines $startIndex+2 $endIndex-1] {
            if {[llength $line] <= 0} {
                puts $outputFileHandle "No difference in $file \n"
                flush $outputFileHandle
                set retVal 1
                return $retVal
            } else {
                puts $outputFileHandle "Found difference in $file while executing sysdatagen \n"
                flush $outputFileHandle
                puts "Difference is $line  \n"

                #check if the difference data is correct or not.

                if {$Table == [lindex $line 0] && $Inserts == [lindex $line 1] && $Updates == [lindex $line 2]} {
                    set retVal ""
                    return $retVal
                } else {
                    set retVal 1
                    return $retVal
                }

            }
        return $retVal
        }

        #Deleting sysdatagen output directory and Rollback the incorrect data from schema

        file delete -force $outdir

        if { [catch {execsql $dbh $insert_Statement} err] } {
                set retVal "Cannot execute sqlstatemnt $err"
                return $retVal
        }

        if { [catch {execsql $dbh $commit_statement} err] } {
                set retVal "Cannot execute sqlstatemnt $err"
                return $retVal
        }
        close $outputFileHandle
    
    }

    -result {  }
    -cleanup {dropAll SysDataGen}
}

# RE-305
test tcl_unit_SysDataGen.version {Unit test for SysDataGen.version  proc} {
    -setup {}
    -body {

        set retval ""

        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            if { [catch {SysDataGen.version} err] } {
                set retval "Cannot execute SysDataGen.version $err"
                return $retval
            }
            if {$retval == ""} {
                return 0
            }
            return 1
        }

    }
    -result { 0 }
    -cleanup {dropAll SysDataGen}
}
# RE-305
test tcl_unit_SysDataGen.revision {Unit test for SysDataGen.revision  proc} {
    -setup {}
    -body {

        set retval ""

        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            if { [catch {SysDataGen.revision} err] } {
                set retval "Cannot execute SysDataGen.version $err"
                return $retval
            }
            if {$retval == ""} {
                return 0
            }
            return 1
        }

    }
    -result { 0 }
    -cleanup {dropAll SysDataGen}
}
# RE-305
test tcl_unit_deleteScriptHeader {Unit test for deleteScriptHeader proc} {
    -setup {}
    -body {
        global sdgInfo
        set retval ""
        set sdgInfo(date_stamp) "DDMMYY"
        set sdgInfo(database) "testingDatabase"
        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            if { [catch {deleteScriptHeader $names_file $values_file $where_file $spool} err] } {
                # set retval "Cannot execute deleteScriptHeader $err"
                lappend retval [list Sequence: $i  INPUT: names_file is: $names_file values_file is : $values_file values_file is : $values_file spool is : $spool EXPECTED:  RETURNED: $err]
                return $retval
            }
            if {$retval == ""} {
                return 0
            }
            return 1
        }

    }
    -result { 0 }
    -cleanup {dropAll SysDataGen}
}
# RE-305
test tcl_unit_reportHeader {Unit test for reportHeader proc} {
    -setup {}
    -body {
        global sdgInfo
        set retval ""
        set sdgInfo(date_stamp) "DDMMYY"
        set sdgInfo(database) "testingDatabase"
        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            if { [catch {reportHeader $names_file $values_file $where_file} err] } {
                # set retval "Cannot execute reportHeader $err"
                lappend retval [list Sequence: $i  INPUT: names_file is: $names_file values_file is : $values_file values_file is : $values_file EXPECTED:  RETURNED: $err]
                return $retval
            }
            if {$retval == ""} {
                return 0
            }
            return 1
        }

    }
    -result { 0 }
    -cleanup {dropAll SysDataGen}
}
# RE-306
test tcl_unit_DMLheader {Unit test for DMLheader proc} {
    -setup {}
    -body {
        global sdgInfo
        set retval ""
        set sdgInfo(date_stamp) "DDMMYY"
        set sdgInfo(database) "testingDatabase"
        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            if { [catch {DMLheader $names_file $values_file $where_file $spool $auto} err] } {
                lappend retval [list Sequence: $i  INPUT: names_file is: $names_file values_file is : $values_file values_file is : $values_file spool is : $spool Auto is : $auto EXPECTED:  RETURNED: $err]
                return $retval
            }
            if {$retval == ""} {
                return 0
            }
            return 1
        }

    }
    -result { 0 }
    -cleanup {dropAll SysDataGen}
}
# RE-306
test tcl_unit_sdg_report {Unit test for sdg_report proc} {
    -setup {}
    -body {
        global sdgInfo
        set retval ""
        set sdgInfo(line_count) 1
        set sdgInfo(maxLines) 50
        set fid [open test_sdg_report.txt w]
        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            if { [catch {sdg_report $line_out $fid} err] } {
                lappend retval [list Sequence: $i  INPUT: line_out is: $line_out fid is $fid EXPECTED:  RETURNED: $err]
                return $retval
            }
            if {$retval == ""} {
                return 0
            }
            return 1
        }
        close $fid
        # delete testing file from current directory
        file delete -force test_sdg_report.txt

    }
    -result { 0 }
    -cleanup {dropAll SysDataGen}
}
# RE-306
test tcl_unit_sdg_list_report {Unit test for sdg_list_report proc} {
    -setup {}
    -body {
        global sdgInfo
        set retval ""
        set sdgInfo(line_count) 1
        set sdgInfo(maxLines) 50
        set fid [open test_sdg_list_report.txt w]
        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            if { [catch {sdg_list_report $line_out $fid} err] } {
                lappend retval [list Sequence: $i  INPUT: line_out is: $line_out fid is $fid EXPECTED:  RETURNED: $err]
                return $retval
            }
            if {$retval == ""} {
                return 0
            }
            return 1
        }
        close $fid
        # delete testing file from current directory
        file delete -force test_sdg_list_report.txt

    }
    -result { 0 }
    -cleanup {dropAll SysDataGen}
}
# RE-306
test tcl_unit_getConcatVals {Unit test for getConcatVals proc} {
    -setup {}
    -body {
        set retval ""
        set result ""
        for {set i 1} {$i <= $no_of_scenarios} {incr i} {

            set inpVar1 [set str$i]
            set inpVar2 [set splitStr$i]
            set outVar [set outval$i]

            if { [catch {set result [getConcatVals $inpVar1 $inpVar2]} err] } {
                lappend retval [list Sequence: $i  INPUT: Str is: $str splitStr is $splitStr EXPECTED: $outVar RETURNED: $err]
            }

            if {$result != $outVar} {
                 lappend retval [list Sequence: $i  INPUT: Str is: $inpVar1 splitStr is $inpVar2 EXPECTED: $outVar RETURNED: $err]
            }
        }
        if {$retval == ""} {
            return 0
        }
        return $retval
    }
    -result { 0 }
    -cleanup {dropAll SysDataGen}
}
# RE-316
test tcl_unit_cleanModelVals {Unit test for cleanModelVals proc} {
    -setup {}
    -body {
        set retval ""
        set result ""
        for {set i 1} {$i <= $no_of_scenarios} {incr i} {

            set inpVar1 [set str$i]
            set inpVar2 [set splitStr$i]
            set outVar [set outval$i]

            if { [catch {set result [cleanModelVals $inpVar1 $inpVar2]} err] } {
                lappend retval [list Sequence: $i  INPUT: Str is: $inpVar1 splitStr is $inpVar2 EXPECTED: $outVar RETURNED: $err]
            }

            if {$result != $outVar} {
                 lappend retval [list Sequence: $i  INPUT: Str is: $inpVar1 splitStr is $inpVar2 EXPECTED: $outVar RETURNED: $err]
            }
        }
        if {$retval == ""} {
            return 0
        }
        return $retval
    }
    -result { 0 }
    -cleanup {dropAll SysDataGen}
}
# RE-316
test tcl_unit_checkUniqueRow {Unit test for checkUniqueRow proc} {
    -setup {}
    -body {
        set retval ""
        set result ""
        # If schema not present in the schema List get it from schema pool

        if { [catch {getLogonHandle $targetConnection} dbh] } {
               set retVal "Could not connect to $dbConn"
               return $retVal
        }
        for {set i 1} {$i <= $no_of_scenarios} {incr i} {

            set inpVar1 [set table$i]
            set inpVar2 [set key_lst$i]
            set inpVar3 [set column_lst$i]
            set inpVar4 [set rowdata$i]
            set inpVar5 [set db_delimit$i]
            set inpVar6 [set metal$i]
            set outVar [set outval$i]

            if { [catch {set result [checkUniqueRow $dbh $inpVar1 $inpVar2 $inpVar3 $inpVar4 $inpVar5 $inpVar6]} err] } {
                lappend retval [list Sequence: $i  INPUT: table is: $inpVar1 key_lst is $inpVar2 column_lst is $inpVar3 rowdata is $inpVar4 db_delimit is $inpVar5 metal is $inpVar6 EXPECTED: $outVar RETURNED: $err]
            }

            if {$result != $outVar} {
                 lappend retval [list Sequence: $i  INPUT: table is: $inpVar1 key_lst is $inpVar2 column_lst is $inpVar3 rowdata is $inpVar4 db_delimit is $inpVar5 metal is $inpVar6 EXPECTED: $outVar RETURNED: $result]
            }
        }
        if {$retval == ""} {
            return 0
        }
        return $retval
    }
    -result { 0 }
    -cleanup {dropAll SysDataGen}
}
# RE-317
test tcl_unit_getUniqueConstraints {Unit test for getUniqueConstraints proc} {
    -setup {}
    -body {
        set retval ""
        set result ""
        # If schema not present in the schema List get it from schema pool
        if { [catch {getLogonHandle $targetConnection} dbh] } {
               set retVal "Could not connect to $dbConn"
               return $retVal
        }
        for {set i 1} {$i <= $no_of_scenarios} {incr i} {

            set inpVar1 [set table$i]
            set inpVar2 [set key_lst$i]
            set inpVar3 [set column_lst$i]
            set outVar [set outval$i]
            # todo the sql does not order the columns for the results.  hence the ordering or column to index is arbitrary.
            # either fix sysdatagen, or change the results check to disregard order
            if { [catch {set result [getUniqueConstraints $dbh $inpVar1 $inpVar2 $inpVar3]} err] } {
                lappend retval [list Sequence: $i  INPUT: table is: $inpVar1 key_lst is $inpVar2 column_lst is $inpVar3 EXPECTED: $outVar RETURNED: $err]
            }

            set out $outVar
            set outcols [lindex $out 0]
            set outindices [lindex $out 1]
            set rcols [lindex $result 0]
            set rindices [lindex $result 1]
            foreach col $rcols ind $rindices {
                if {[set q [lsearch $outcols $col]] < 0} {
                    lappend retval [list Sequence: $i  INPUT: table is: $inpVar1 extra $col]
                    continue
                }
                if {$ind != [lindex $outindices $q]} {
                    lappend retval "wrong ordering"
                }
            }
            foreach col $outcols ind $outindices {
                if {[set q [lsearch $rcols $col]] < 0} {
                    lappend retval [list Sequence: $i  INPUT: table is: $inpVar1 missing $col]
                    continue
                }
                if {$ind != [lindex $rindices $q]} {
                    lappend retval "wrong ordering"
                }
            }
        }
        if {$retval == ""} {
            return 0
        }
        return $retval
    }
    -result { 0 }
    -cleanup {dropAll SysDataGen}
}
# RE-317
test tcl_unit_doMoves {Unit test for doMoves proc} {
    -setup {}
    -body {
        global sdgInfo
        set retval ""
        set result ""
        set sdgInfo(auditColumns) "true"

        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            set inpVar1 [set table$i]
            set inpVar2 [set key_lst$i]
            set inpVar3 [set column_lst$i]
            set inpVar4 [set inserts$i]
            set inpVar5 [set moveRows$i]
            set inpVar6 [set moveVals$i]
            set outVar [set outval$i]

            if { [catch {set result [doMoves $inpVar1 $inpVar2 $inpVar3 $inpVar4 $inpVar5 $inpVar6]} err] } {
                lappend retval [list Sequence: $i  INPUT: table is: $inpVar1 key_lst is inpVar2 column_lst is $inpVar3 EXPECTED: $outVar RETURNED: $err]
            }

            if {$result != $outVar} {
                 lappend retval [list Sequence: $i  INPUT: table is: $inpVar1 key_lst is $inpVar2 column_lst is $inpVar3 EXPECTED: $outVar RETURNED: $err]
            }
        }
        if {$retval == ""} {
            return 0
        }
        return $retval
    }
    -result { 0 }
    -cleanup {dropAll SysDataGen}
}
# RE-317
test tcl_unit_doInserts {Unit test for doInserts proc} {
    -setup {}
    -body {
        set retval ""
        set result ""
        # If schema not present in the schema List get it from schema pool
        if { [catch {getLogonHandle $targetConnection} dbh] } {
               set retVal "Could not connect to $dbh"
               return $retVal
        }
        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            set sdg [set sdginfo$i]
            set sdgInfo(auditColumns) $sdg
            set inpVar1 [set table$i]
            set inpVar2 [set key_lst$i]
            set inpVar3 [set column_lst$i]
            set inpVar4 [set insertData$i]
            set outVar [set outval$i]

            if { [catch {set result [doInserts $dbh $inpVar1 $inpVar2 $inpVar3 $inpVar4]} err] } {
                lappend retval [list Sequence: $i  INPUT: table is: $inpVar1 key_lst is $inpVar2 column_lst is $inpVar3 Insert Data is $inpVar4 EXPECTED: $outVar RETURNED: $err]
            }

            if {$result != $outVar} {
                 lappend retval [list Sequence: $i  INPUT: table is: $inpVar1 key_lst is $inpVar2 column_lst is $inpVar3 Insert Data is $inpVar4 EXPECTED: $outVar RETURNED: $err]
            }
        }
        if {$retval == ""} {
            return 0
        }
        return $retval
    }
    -result { 0 }
    -cleanup {dropAll SysDataGen}
}
test tcl_unit_doInserts_2 {Unit test for doInserts proc} {
    -setup {}
    -body {
        set retval ""
        set result ""
        # If schema not present in the schema List get it from schema pool
        if { [catch {getLogonHandle $targetConnection} dbh] } {
               set retVal "Could not connect to $dbh"
               return $retVal
        }
        set valuesfile [glob $MODEL_FILES_DIRECTORY/$modelInputParam/*VALUES.txt]
        set namesfile [glob $MODEL_FILES_DIRECTORY/$modelInputParam/*NAMES.txt]
        set fid [open $valuesfile r]
        set values [read $fid]
        close $fid 
        set fid [open $namesfile r]
        set names [split [read $fid] \n]
        close $fid 
        
        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            set table [set table$i]
            set uid [set PKVal$i]
            set auditYN false
            catch {set auditYN [set auditYN$i]}
            set sdgInfo(auditColumns) $auditYN
            set FKcount 0
            catch {set FKcount [set [FKS$i]]}
            set namei [lsearch $names $table*]
            set thisNameList [lindex $names $namei]
            regexp -- "->$table.*->" $values vals
            regexp "$uid.*?\\n" $vals thisValList
            
            set pks [getPKNames $thisNameList]
            set cols [getColNames $thisNameList]
            set pkVals [getPKVals $thisValList]
            set colVals [getColVals $thisValList]
            set VALS [concat $pkVals $colVals]
            if { [catch {set SQLresult [doInserts $dbh $table $pks $cols [list $VALS]]} err] } {
                lappend retval  "doInserts error RETURNED: $err"
            }

            set test 0
            set compare 1
            incr test [regsub -nocase ".*insert\\s+into\\s+$table\\s+" $SQLresult "" result]
            foreach pk $pks {
                incr compare
                incr test [regsub -nocase ".*$pk\\s*," $result "" result]
            }
            foreach col $cols {
                incr compare
                incr test [regsub -nocase ".*$col" $result "" result]
            }
            if {$auditYN == "true"} {
                incr compare 2
                incr test [regsub -nocase ".*USR_UID_CREATED_BY\\s*," $result "" result]
                incr test [regsub -nocase ".*CREATE_DATE" $result "" result]
            }
            foreach val $VALS {
                incr compare
                incr test [regsub -nocase ".*?$val\\s*?" $result "" result]
            }
            if {$auditYN == "true"} {
                incr compare 2
                incr test [regsub -nocase ".*-\\d\\s*," $result "" result]
                incr test [regsub -nocase ".*sysdate" $result "" result]
            }
            set fk 0
            while {$fk < $FKcount} {
                incr compare
                incr fk
                if {[regsub -nocase "Alter\\s*table\\s$table.*disable\\s+constraint" $result] && [regexp -nocase "Alter\\s*table\\s$table.*enable\\s+constraint" $result]} {
                    incr test
                }
            }
            if {$compare != $test} {
                 lappend retval [list Sequence: $i  INPUT: table is: $table found: $test expected: $compare \n$SQLresult $pks $cols $VALS $auditYN]
            }
        }
        return $retval
    }
    -result {}
    -cleanup {dropAll SysDataGen}
}
# RE-321
test tcl_unit_joinSQL {Unit test for joinSQL proc} {
    -setup {}
    -body {
        set retval ""
        set result ""

        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            set inpVar1 [set data$i]
            set inpVar2 [set joiner$i]
            set outVar [set outval$i]

            if { [catch {set result [joinSQL $inpVar1 $inpVar2]} err] } {
                lappend retval [list Sequence: $i  INPUT: Data is: $inpVar1 Joiner is $inpVar2 EXPECTED: $outVar RETURNED: $err]
            }

            if {$result != $outVar} {
                 lappend retval [list Sequence: $i  INPUT: Data is: $inpVar1 Joiner is $inpVar2 EXPECTED: $outVar RETURNED: $err]
            }
        }
        if {$retval == ""} {
            return 0
        }
        return $retval
    }
    -result { 0 }
    -cleanup {dropAll SysDataGen}
}
# RE-321
test tcl_unit_quoteSQL {Unit test for quoteSQL proc} {
    -setup {}
    -body {
        set retval ""
        set result ""

        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            set inpVar1 [set datum$i]
            set outVar [set outval$i]

            if { [catch {set result [quoteSQL $inpVar1]} err] } {
                lappend retval [list Sequence: $i  INPUT: Data is: $inpVar1 EXPECTED: $outVar RETURNED: $err]
            }

            if {$result != $outVar} {
                 lappend retval [list Sequence: $i  INPUT: Data is: $inpVar1 EXPECTED: $outVar RETURNED: $err]
            }
        }
        if {$retval == ""} {
            return 0
        }
        return $retval
    }
    -result { 0 }
    -cleanup {dropAll SysDataGen}
}
# RE-321
test tcl_unit_doMaps {Unit test for doMaps proc} {
    -setup {}
    -body {
        set retval ""
        set result ""
        if { [catch {getLogonHandle $targetConnection} dbh] } {
               set retVal "Could not connect to $targetConnection"
               return $retVal
        }
        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            set sdg [set sdginfo$i]
            set sdgInfo(auditColumns) $sdg
            set inpVar1 [set table$i]
            set inpVar2 [set key_name_lst$i]
            set inpVar3 [set column_name_lst$i]
            set inpVar4 [set model_data$i]
            set inpVar5 [set mapRows$i]
            set inpVar6 [set mapVals$i]
            set inpVar7 [set mapPKs$i]
            set outVar [set outval$i]

            if { [catch {set result [doMaps $dbh $inpVar1 $inpVar2 $inpVar3 $inpVar4 $inpVar5 $inpVar6 $inpVar7]} err] } {
                lappend retval [list Sequence: $i  INPUT: Table is: $inpVar1 key_name_lst is: $inpVar2 column_name_lst is: $inpVar3 model_data is: $inpVar4 mapRows is: $inpVar5 mapVals is: $inpVar6 mapPKs is: $inpVar7 EXPECTED: $outVar RETURNED: $err]
            }

            if {$result != $outVar} {
                lappend retval [list Sequence: $i  INPUT: Table is: $inpVar1 key_name_lst is: $inpVar2 column_name_lst is: $inpVar3 model_data is: $inpVar4 mapRows is: $inpVar5 mapVals is: $inpVar6 mapPKs is: $inpVar7 EXPECTED: $outVar RETURNED: $err]
            }
        }
        if {$retval == ""} {
            return 0
        }
        return $retval
    }
    -result { 0 }
    -cleanup {dropAll SysDataGen}
}
# RE-322
test tcl_unit_doUpdates {Unit test for doUpdates proc} {
    -setup {}
    -body {
        set retval ""
        set result ""

        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            set sdg [set sdginfo$i]
            set sdgInfo(auditColumns) $sdg
            set inpVar1 [set table$i]
            set inpVar2 [set update$i]
            set inpVar3 [set key_lst$i]
            set outVar [set outval$i]

            if { [catch {set result [doUpdates $inpVar1 $inpVar2 $inpVar3]} err] } {
                lappend retval [list Sequence: $i  INPUT: table is: $inpVar1 key_lst is $inpVar3 Update List is $inpVar2 EXPECTED: $outVar RETURNED: $err]
            }

            if {$result != $outVar} {
                 lappend retval [list Sequence: $i  INPUT: table is: $inpVar1 key_lst is $inpVar3 Update List is $inpVar2 EXPECTED: $outVar RETURNED: $err]
            }
        }
        if {$retval == ""} {
            return 0
        }
        return $retval
    }
    -result { 0 }
    -cleanup {dropAll SysDataGen}
}
# RE-322
test tcl_unit_doDeletes {Unit test for doDeletes proc} {
    -setup {}
    -body {
        set retval ""
        set result ""

        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            set inpVar1 [set table$i]
            set inpVar2 [set delete$i]
            set inpVar3 [set key_lst$i]
            set inpVar4 [set where$i]
            set outVar [set outval$i]

            if { [catch {set result [doDeletes $inpVar1 $inpVar2 $inpVar3 $inpVar4]} err] } {
                lappend retval [list Sequence: $i  INPUT: table is: $inpVar1 Delete is $inpVar2 Key List is $inpVar3 Where is $inpVar4 EXPECTED: $outVar RETURNED: $err]
            }

            if {$result != $outVar} {
                 lappend retval [list Sequence: $i  INPUT: table is: $inpVar1 Delete is $inpVar2 Key List is $inpVar3 Where is $inpVar4 EXPECTED: $outVar RETURNED: $err]
            }
        }
        if {$retval == ""} {
            return 0
        }
        return $retval
    }
    -result { 0 }
    -cleanup {dropAll SysDataGen}
}
# RE-322
test tcl_unit_lgetThese {Unit test for lgetThese proc} {
    -setup {}
    -body {
        set retval ""
        set result ""

        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            set inputvar1 [set thelist$i]
            set inputvar2 [set theindices$i]
            set outVar [set outval$i]

            if { [catch {set result [lgetThese $inputvar1 $inputvar2]} err] } {
                lappend retval [list Sequence: $i  INPUT: List is: $inputvar1 Indices are: $inputvar2 EXPECTED: $outVar RETURNED: $err]
            }

            if {$result != $outVar} {
                 lappend retval [list Sequence: $i  INPUT: List is: $inputvar1 Indices are: $inputvar2 EXPECTED: $outVar RETURNED: $result]
            }
        }
        if {$retval == ""} {
            return 0
        }
        return $retval
    }
    -result { 0 }
    -cleanup {dropAll SysDataGen}
}
# RE-328
test tcl_unit_keysToAdd {Unit test for keysToAdd proc} {
    -setup {}
    -body {
        set retval ""
        set result ""

        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            set inputvar1 [set table$i]
            set inputvar2 [set key_name$i]
            set inputvar3 [set new_key_lst$i]
            # set outVar [set outval$i]
            set sdgInfo(line_count) 1
            set sdgInfo(maxLines) 20
            set fid [open test_sdg_list_report.txt w]

            if { [catch {set result [keysToAdd $fid $inputvar1 $inputvar2 $inputvar3]} err] } {
                lappend retval [list Sequence: $i  INPUT: Table is: $inputvar1 key_name is: $inputvar2 new_key_lst are: $inputvar3 EXPECTED: "" RETURNED: $err]
            }
            close $fid

            # delete testing file from current directory
            file delete -force test_sdg_list_report.txt

        }
        if {$retval == ""} {
            return 0
        }
        return $retval
    }
    -result { 0 }
    -cleanup {dropAll SysDataGen}
}
# RE-328
test tcl_unit_keysToUpdate {Unit test for keysToUpdate proc} {
    -setup {}
    -body {
        set retval ""
        set result ""

        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            set inputvar1 [set table$i]
            set inputvar2 [set key_name$i]
            set inputvar3 [set new_key_lst$i]
            # set outVar [set outval$i]
            set sdgInfo(line_count) 1
            set sdgInfo(maxLines) 20
            set fid [open test_sdg_list_report.txt w]

            if { [catch {set result [keysToUpdate $fid $inputvar1 $inputvar2 $inputvar3]} err] } {
                lappend retval [list Sequence: $i  INPUT: Table is: $inputvar1 key_name is: $inputvar2 new_key_lst are: $inputvar3 EXPECTED: "" RETURNED: $err]
            }
            close $fid

            # delete testing file from current directory
            file delete -force test_sdg_list_report.txt
            # if {$result != [expr $$outVar]} {
                 # lappend retval [list Sequence: $i  INPUT: List is: [expr $$inputvar1] Indices are: [expr $$inputvar2] EXPECTED: [expr $$outVar] RETURNED: $result]
            # }

        }
        if {$retval == ""} {
            return 0
        }
        return $retval
    }
    -result { 0 }
    -cleanup {dropAll SysDataGen}
}
# RE-328
test tcl_unit_keysToMove {Unit test for keysToMove proc} {
    -setup {}
    -body {
        set retval ""
        set result ""

        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            set inputvar1 [set table$i]
            set inputvar2 [set key_name$i]
            set inputvar3 [set modvals$i]
            set inputvar4 [set new_key_lst$i]
            # set outVar [set outval$i]
            set sdgInfo(line_count) 1
            set sdgInfo(maxLines) 20
            set fid [open test_sdg_list_report.txt w]

            if { [catch {set result [keysToMove $fid $inputvar1 $inputvar2 $inputvar3 $inputvar4]} err] } {
                lappend retval [list Sequence: $i  INPUT: Table is: $inputvar1 key_name is: $inputvar2 Modval are: $inputvar3 new_key_lst are: $inputvar4 EXPECTED: "" RETURNED: $err]
            }
            close $fid

            # delete testing file from current directory
            file delete -force test_sdg_list_report.txt
            # if {$result != [expr $$outVar]} {
                 # lappend retval [list Sequence: $i  INPUT: List is: [expr $$inputvar1] Indices are: [expr $$inputvar2] EXPECTED: [expr $$outVar] RETURNED: $result]
            # }

        }
        if {$retval == ""} {
            return 0
        }
        return $retval
    }
    -result { 0 }
    -cleanup {dropAll SysDataGen}
}
# RE-328
test tcl_unit_keysToMap {Unit test for keysToMap proc} {
    -setup {}
    -body {
        set retval ""
        set result ""

        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            set inputvar1 [set table$i]
            set inputvar2 [set key_name$i]
            set inputvar3 [set modvals$i]
            set inputvar4 [set new_key_lst$i]
            # set outVar [set outval$i]
            set sdgInfo(line_count) 1
            set sdgInfo(maxLines) 20
            set fid [open test_sdg_list_report.txt w]

            if { [catch {set result [keysToMap $fid $inputvar1 $inputvar2 $inputvar3 $inputvar4]} err] } {
                lappend retval [list Sequence: $i  INPUT: Table is: $inputvar1 key_name is: $inputvar2 Modval are: $inputvar3 new_key_lst are: $inputvar4 EXPECTED: "" RETURNED: $err]
            }
            close $fid

            # delete testing file from current directory
            file delete -force test_sdg_list_report.txt
            # if {$result != [expr $$outVar]} {
                 # lappend retval [list Sequence: $i  INPUT: List is: [expr $$inputvar1] Indices are: [expr $$inputvar2] EXPECTED: [expr $$outVar] RETURNED: $result]
            # }

        }
        if {$retval == ""} {
            return 0
        }
        return $retval
    }
    -result { 0 }
    -cleanup {dropAll SysDataGen}
}
# RE-335
test tcl_unit_keysToMapCollision {Unit test for keysToMapCollision proc} {
    -setup {}
    -body {
        set retval ""
        set result ""

        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            set inputvar1 [set table$i]
            set inputvar2 [set key_name$i]
            # set outVar [set outval$i]
            set sdgInfo(line_count) 1
            set sdgInfo(maxLines) 20
            set fid [open test_sdg_list_report.txt w]

            if { [catch {set result [keysToMapCollision $fid $inputvar1 $inputvar2]} err] } {
                lappend retval [list Sequence: $i  INPUT: Table is: $inputvar1 key_name is: $inputvar2 EXPECTED: "" RETURNED: $err]
            }
            close $fid

            # delete testing file from current directory
            file delete -force test_sdg_list_report.txt

        }
        if {$retval == ""} {
            return 0
        }
        return $retval
    }
    -result { 0 }
    -cleanup {dropAll SysDataGen}
}
# RE-335
test tcl_unit_outputWithCommits {Unit test for outputWithCommits  proc} {
    -setup {}
    -body {
        set retval ""
        set result ""

        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            set inputvar1 [set statements$i]
            set inputvar2 [set commitcount$i]
            set outVar [set outval$i]

            if { [catch {set result [outputWithCommits $inputvar1 $inputvar2]} err] } {
                lappend retval [list Sequence: $i  INPUT: SQL Statements is: $inputvar1 Commitcount is: $inputvar2 EXPECTED: $outVar RETURNED: $err]
            }

            if {$result != $outVar} {
                lappend retval [list Sequence: $i  INPUT: SQL Statements is: $inputvar1 Commitcount is: $inputvar2 EXPECTED: $outVar RETURNED: $result]
            }

        }
        if {$retval == ""} {
            return 0
        }
        return $retval
    }
    -result { 0 }
    -cleanup {dropAll SysDataGen}
}
# RE-335
test tcl_unit_nextPage {Unit test for nextPage  proc} {
    -setup {}
    -body {
        set retval ""
        set result ""

        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            set outVar [set outval$i]
            set sdg [set pageCount$i]
            set sdgInfo(page_count) $sdg
            set sdgInfo(date_stamp) "MM/DD/YYYY"

            if { [catch {set result [nextPage]} err] } {
                lappend retval [list Sequence: $i EXPECTED: $outVar RETURNED: $err]
            }

            if {$result != $outVar} {
                lappend retval [list Sequence: $i EXPECTED: $outVar RETURNED: $result]
            }

        }
        if {$retval == ""} {
            return 0
        }
        return $retval
    }
    -result { 0 }
    -cleanup {dropAll SysDataGen}
}

# RE-346
test tcl_unit_pueUsage {Unit test for pueUsage  proc} {
    -setup {}
    -body {
        set retval 1
        set result ""

        if { [catch {[pueUsage]} err] } {
             set retval 0
        }

        return $retval
    }
    -result { 0 }
    -cleanup {dropAll SysDataGen}
}

# RE-346
test tcl_unit_pueHelp {Unit test for pueHelp  proc} {
    -setup {}
    -body {
        set retval 1
        set result ""

        if { [catch {pueHelp]} err] } {
             set retval 0
        }

        return $retval
    }
    -result { 0 }
    -cleanup {dropAll SysDataGen}
}

# RE-346
test tcl_unit_preUpgradeEvalgetDescription {Unit test for preUpgradeEval.getDescription  proc} {
    -setup {}
    -body {
        set retval 1
        set result ""

        if { [catch {[preUpgradeEval.getDescription]} err] } {
             set retval 0
        }

        return $retval
    }
    -result { 0 }
    -cleanup {dropAll SysDataGen}
}
# RE-343
test tcl_unit_DEBUG_SDG_START {Positive Unit test for DEBUG_SDG_START  proc} {
    -setup {}
    -body {
        set retval ""
        set result ""
        set sdgInfo(_debug_out) ""
        set sdgInfo(_SDG_DEBUG) $arrayVal1

        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            set outVar outval$i
            if { [catch {set result [_DEBUG_SDG_START]} err] } {

                if {![file exists $fileName]} {
                    lappend retval [list Sequence: $i EXPECTED: "$fileName should exist" RETURNED: "Cannot find $fileName"]
                }

            }

        }

        if {$retval!=""} {
            return $retval
        } else { return 0 }

    }
    -result { 0 }
    -cleanup {dropAll SysDataGen}
}
# RE-343
test tcl_unit_SDG_PUTT {Unit test for _SDG_PUTT proc} {
    -setup {}
    -body {

        set retval ""
        set result ""
        global sdgInfo
        set sdgInfo(_debug_out) [open $fileName a]

        for {set i 1} {$i <= $no_of_scenarios} {incr i} {

           if { [catch {set result [_SDG_PUTT]} err] } {

                if {![file exists $fileName]} {
                     lappend retval [list Sequence: $i EXPECTED: "$fileName should exist" RETURNED: "Cannot find $fileName"]
                }

            }
        }

        if {$retval!=""} {
            return $retval
        } else { return 0 }

    }
    -result { 0 }
    -cleanup {dropAll SysDataGen}
}
# RE-343
test tcl_unit_DEBUG_SDG_END {Unit test for _SDG_PUTT proc} {
    -setup {}
    -body {

        set retval ""
        set result ""
        global sdgInfo
        set sdgInfo(_debug_out) [open $fileName a]

        for {set i 1} {$i <= $no_of_scenarios} {incr i} {

           if { [catch {set result [_DEBUG_SDG_END]} err] } {

                if {![file exists $fileName]} {
                     lappend retval [list Sequence: $i EXPECTED: "$fileName should exist" RETURNED: "Cannot find $fileName"]
                }

            }
        }

        if {$retval!=""} {
            return $retval
        } else { return 0 }

    }
    -result { 0 }
    -cleanup {dropAll SysDataGen}
}
# RE-345
test tcl_unit_preUpgradeEval.version {Unit test for preUpgradeEval.version  proc} {
    -setup {}
    -body {

        set retval ""

        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            if { [catch {preUpgradeEval.version} err] } {
                set retval "Cannot execute preUpgradeEval.version $err"
                return $retval
            }
            if {$retval == ""} {
                return 0
            }
            return 1
        }

    }
    -result { 0 }
    -cleanup {dropAll preUpgradeEval}
}
# RE-345
test tcl_unit_preUpgradeEval.revision {Unit test for preUpgradeEval.revision  proc} {
    -setup {}
    -body {

        set retval ""

        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            if { [catch {preUpgradeEval.revision} err] } {
                set retval "Cannot execute preUpgradeEval.version $err"
                return $retval
            }
            if {$retval == ""} {
                return 0
            }
            return 1
        }

    }
    -result { 0 }
    -cleanup {dropAll preUpgradeEval}
}
# RE-385
test tcl_unit_checkSchemaData {Unit test for checkSchemaData proc} {
    -setup {}
    -body {
        set retval ""
        set result ""
        set log [open tcl_unit_checkSchemaData.txt w]
        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            if { [catch {getLogonHandle $targetConnection} dbh] } {
                set retVal "Could not connect to $targetConnection"
            }
            set inputvar3 [set currentMod$i]
            set outVar [set outval$i]
            # outdir passed in via load file
            if { [catch {set result [checkSchemaData $log $dbh $targetConnection $inputvar3 $outdir]} err] } {
                lappend retval [list Sequence: $i  EXPECTED: $outVar RETURNED: $err]
                # return $retval
            }
            if {$result != $outVar} {
                lappend retval [list Sequence: $i EXPECTED: $outVar RETURNED: $result]
            }
        }
        close $log

        # delete testing file from current directory
        if {$retval == ""} {
            file delete -force tcl_unit_checkSchemaData.txt
            return 0
        }
        return $retval

    }
    -result { 0 }
    -cleanup {dropAll preUpgradeEval}
}
# RE-385
test tcl_unit_checkPermissions {Unit test for checkPermissions proc} {
    -setup {}
    -body {
        set retval ""
        set result ""
        set dbConn ""
        if {$scenario == "positive"} {
            # If schema not present in the schema List get it from schema pool
        }
        if { [catch {getLogonHandle $targetConnection} dbh] } {
               set retVal "Could not connect to $targetConnection"
               # return $retVal
        }
        set log [open tcl_unit_checkPermissions.txt w]
        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            set outVar [set outval$i]
            if { [catch {set result [checkPermissions $log $dbh]} err] } {
                # lappend retval [list Sequence: $i  EXPECTED: [expr $$outVar] RETURNED: $err]
                # return $retval
            }
            if {$result != $outVar} {
                lappend retval [list Sequence: $i EXPECTED: $outVar RETURNED: $result]
            }
        }
        close $log
        # delete testing file from current directory

        if {$retval == ""} {
            return 0
            file delete -force tcl_unit_checkPermissions.txt
        }
        return $retval

    }
    -result { 0 }
    -cleanup {dropAll preUpgradeEval}
}
# RE-385
test tcl_unit_compareModelCodes  {Unit test for compareModelCodes proc} {
    -setup {}
    -body {
        set retval ""
        set result ""
        set log [open log.txt w]
        # If schema not present in the schema List get it from schema pool
        if { [catch {getLogonHandle $targetConnection} dbh] } {
               set retVal "Could not connect to $targetConnection"
               # return $retVal
        }
        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            set inputvar1 [set currentMod$i]
            set inputvar2 [set targetMod$i]
            set outVar [set outval$i]
            if {$scenario == "positive"} {
                if { [catch {set result [compareModelCodes $log $inputvar1 $inputvar2]} err] } {
                    lappend retval [list Sequence: $i  EXPECTED: $outVar RETURNED: $err]
                    # return $retval
                }
                if {$result != $outVar} {
                    lappend retval [list Sequence: $i EXPECTED: $outVar RETURNED: $result]
                }
            } else {
                if { [catch {set result [compareModelCodes $log $inputvar1 $inputvar2]} err] } {
                return 0
            }
            }

        }
        close $log
        # delete testing file from current directory
        file delete -force log.txt
        if {$retval == ""} {
            return 0
        }
        return $retval

    }
    -result { 0 }
    -cleanup {dropAll preUpgradeEval}
}

# RE-388
test tcl_unit_getPUEInputs {Unit test for getPUEInputs} {
    -setup {}
    -body {
        set results ""
        set retval 1

        if { [catch {[getPUEInputs $database1 $convtext1 $email1 $silent1 4]} err] } {
            set retval 0
        } else {
            return 1
        }
        if { [catch {[getPUEInputs $database1 $convtext1 $email1 3]} err] } {
            set retval 0
        } else {
            return 1
        }
        if { [catch {[getPUEInputs $database1 1]} err] } {
            set retval 0
        }

        return $retval
    }
    -result { 0 }
    -cleanup {dropAll dbCompare}
}
# RE-387
test tcl_unit_validateShsEntries {Unit test for validateShsEntries proc} {
    -constraints {}
    -setup {}
    -body {
        set retval ""
        set result ""
        set log [open log.txt w]
        if { [catch {getLogonHandle $targetConnection} dbh] } {
               set retVal "Could not connect to $targetConnection"
        }
        set SQL_Statement "drop table EXCEPTIONS"
        if { [catch {execsql use $dbh $SQL_Statement} err]} {
           return "Could not execute $SQL_Statement $err [getinfo all]"
        }
        if {$scenario == "negative"} {
            set SQL_Statement "create table EXCEPTIONS (test VARCHAR2(10))"
            if { [catch {execsql use $dbh $SQL_Statement} err] || $err != 0 } {
               return "Could not execute $SQL_Statement $err"
            }
        }

        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
                set outVar [set outval$i]
                if { [catch {set result [validateShsEntries $log $dbh]} err] } {
                    lappend retval [list Sequence: $i  EXPECTED: $outVar RETURNED: $err]
                }
                if {$result != $outVar} {
                    lappend retval [list Sequence: $i EXPECTED: $outVar RETURNED: $result]
                }
        }
        set SQL_Statement "drop table EXCEPTIONS"
        if { [catch {execsql use $dbh $SQL_Statement} err]} {
           return "Could not execute $SQL_Statement $err [getinfo all]"
        }
        logoff $dbh
        close $log
        # delete testing file from current directory
        file delete -force log.txt
        if {$retval == ""} {
            return 0
        }
        return $retval
    }
    -result { 0 }
    -cleanup {dropAll preUpgradeEval}
}
test tcl_unit_validateShsEntries_2 {Unit test for validateShsEntries proc} {
    -constraints {}
    -setup {}
    -body {
        set retval ""
        set result ""
        set log [open log.txt w]
        if { [catch {getLogonHandle $targetConnection} dbh] } {
               set retVal "Could not connect to $targetConnection"
        }
        set SQL_Statement "select SHS_UID into :uid from SHS_SCHEMA_HISTORY where SHS_SQL_SCRIPT_NAME like 'CR%.sql' and rownum < 2"
        if { [catch {execsql use $dbh $SQL_Statement} err]} {
           return "Could not execute $SQL_Statement $err [getinfo all]"
        }
        set SQL_Statement "update SHS_SCHEMA_HISTORY set SHS_RESULTS = 'Failed' where SHS_UID = $uid"
        if { [catch {execsql use $dbh $SQL_Statement} err]} {
           return "Could not execute $SQL_Statement $err [getinfo all]"
        }

        if { [catch {set result [validateShsEntries $log $dbh]} err] } {
            lappend retval [list Sequence: EXPECTED: 0 RETURNED: $err]
        }

        set SQL_Statement "update SHS_SCHEMA_HISTORY set SHS_RESULTS = 'Successful' where SHS_UID = $uid"
        if { [catch {execsql use $dbh $SQL_Statement} err]} {
           return "Could not execute $SQL_Statement $err [getinfo all]"
        }
        execsql use $dbh "commit"
        logoff $dbh
        close $log
        # delete testing file from current directory
        file delete -force log.txt
        if {$retval == ""} {
            return 0
        }
        return $retval
    }
    -result { 0 }
    -cleanup {dropAll preUpgradeEval}
}
# RE-387
test tcl_unit_checkModelResources {Unit test for checkModelResources proc} {
    -setup {}
    -body {
        set retval ""
        set result ""
        set log [open log.txt w]

        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            set inputvar1 [set currentMod$i]
            set inputvar2 [set short_target$i]
            set inputvar3 [set targetProduct$i]
            set inputvar4 [set target_model$i]
            set outVar [set outval$i]
            if { [catch {set result [checkModelResources $log $inputvar1 $inputvar2 $inputvar3 $inputvar4]} err] } {
                lappend retval [list Sequence: $i currentMod is: $inputvar1 short_target is:$inputvar2 targetProduct is:$inputvar3 target_model is: $inputvar4 EXPECTED: $outVar RETURNED: $err]
            }
            if {$result != $outVar} {
                lappend retval [list Sequence: $i currentMod is: $inputvar1 short_target is:$inputvar2 targetProduct is:$inputvar3 target_model is: $inputvar4 EXPECTED: $outVar RETURNED: $result]
            }
        }
        close $log
        # delete testing file from current directory
        file delete -force log.txt
        if {$retval == ""} {
            return 0
        }
        return $retval
    }
    -result { 0 }
    -cleanup {dropAll preUpgradeEval}
}
# RE-387
test tcl_unit_checkToolResources {Unit test for checkToolResources proc} {
    -setup {}
    -body {
        set retval ""
        set result ""
        set log [open log.txt w]

        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            set inputvar1 [set targetProduct$i]
            set outVar [set outval$i]
            if { [catch {set result [checkToolResources $log $inputvar1]} err] } {
                lappend retval [list Sequence: $i targetProduct is: $inputvar1 EXPECTED: $outVar RETURNED: $err]
            }
            if {$result != $outVar} {
                lappend retval [list Sequence: $i targetProduct is: $inputvar1 EXPECTED: $outVar RETURNED: $result]
            }
        }
        close $log
        # delete testing file from current directory
        file delete -force log.txt
        if {$retval == ""} {
            return 0
        }
        return $retval
    }
    -result { 0 }
    -cleanup {dropAll preUpgradeEval}
}
# RE-347
test tcl_unit_printHeader {Unit test for printHeader proc} {
    -setup {}
    -body {

        set retval ""
        set result ""

        for {set i 1} {$i <= $no_of_scenarios} {incr i} {

              set inputvar1 [set text$i]
            # set outVar outval$i
              set fh_printHeader [open $log1 w]

            if { [catch {set result [printHeader $fh_printHeader $inputvar1]} err] } {

                    if { $result != 0} {
                        lappend retval [list Sequence: $i EXPECTED: "$outval1" RETURNED: "$result"]
                    }

                }
        }

        close $fh_printHeader

        catch {file delete -force $log1}

        if {$retval!=""} {
            return $retval
        } else { return 0 }

    }
    -result { 0 }
    -cleanup {dropAll preUpgradeEval}
}
# RE-347
test tcl_unit_printHeaderN {Unit test for printHeader proc} {
    -setup {}
    -body {

        set retval ""
        set result ""

        for {set i 1} {$i <= $no_of_scenarios} {incr i} {

              set inputvar1 [set text$i]

            if { [catch {set result [printHeader "" $inputvar1]} err] } {

                    if { $result != ""} {
                        lappend retval [list Sequence: $i EXPECTED: "$outval1" RETURNED: "$result"]
                    }

                }
        }

        if {$retval!=""} {
            return $retval
        } else { return 0 }

    }
    -result { 0 }
    -cleanup {dropAll preUpgradeEval}
}
# RE-347
test tcl_unit_printResult {Unit test for printHeader proc} {
    -setup {}
    -body {

        set retval ""
        set result ""

        for {set i 1} {$i <= $no_of_scenarios} {incr i} {

              set inputvar1 [set text$i]
              set fh_printHeader [open $log1 w]

            if { [catch {set result [printResult $fh_printHeader $inputvar1]} err] } {

                    if { $result != 0} {
                        lappend retval [list Sequence: $i EXPECTED: "$outval1" RETURNED: "$result"]
                    }

                }
        }

        close $fh_printHeader

        catch {file delete -force $log1}

        if {$retval!=""} {
            return $retval
        } else { return 0 }

    }
    -result { 0 }
    -cleanup {dropAll preUpgradeEval}
}
# RE-347
test tcl_unit_printPueFooter {Unit test for printHeader proc} {
    -setup {}
    -body {

        set retval ""
        set result ""

        for {set i 1} {$i <= $no_of_scenarios} {incr i} {


            if { [catch {getLogonHandle $targetConnection} dbh] } {
                set retVal "Could not connect to $targetConnection"
            }

            catch {set result [printPueFooter $dbConn $currentver $targetver $outdir $total_minutes $total_seconds]} err

            foreach line $result {

                if {$line!=$outval} {
                    return 0
                } else {
                    lappend retval [list Sequence: $i EXPECTED: "$outval" RETURNED: "$line"]
                }
            }

        }

        if {$retval!=""} {
            return $retval
        } else { return 0 }

    }
    -result { 0 }
    -cleanup {dropAll preUpgradeEval}
}

# RE-420
test tcl_unit_AutoScript.version {Unit test for AutoScript.version  proc} {
    -setup {}
    -body {

        set retval ""

        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            if { [catch {AutoScript.version} err] } {
                set retval "Cannot execute AutoScript.version $err"
                return $retval
            }
            if {$retval == ""} {
                return 0
            }
            return 1
        }

    }
    -result { 0 }
    -cleanup {dropAll autoScript}
}
# RE-420
test tcl_unit_AutoScript.revision {Unit test for AutoScript.revision  proc} {
    -setup {}
    -body {

        set retval ""

        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            if { [catch {AutoScript.revision} err] } {
                set retval "Cannot execute AutoScript.revision $err"
                return $retval
            }
            if {$retval == ""} {
                return 0
            }
            return 1
        }

    }
    -result { 0 }
    -cleanup {dropAll autoScript}
}
# RE-420
test tcl_unit_asc_tool {Unit test for asc_tool proc} {
    -setup {}
    -body {

        set retval ""

        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            if { [catch {asc_tool} err] } {
                set retval "Cannot execute AutoScript.revision $err"
                return $retval
            }
            if {$retval == ""} {
                return 0
            }
            return 1
        }

    }
    -result { 0 }
    -cleanup {dropAll autoScript}
}
# RE-421
test tcl_unit_getArgsAutoScript {Unit test for getArgsAutoScript proc} {
    -setup {}
    -body {
        set retval ""
        set result ""

        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            set inputvar1 [set argv$i]
            set inputvar2 [set argc$i]
            set outVar [set outval$i]
            if { [catch {set result [getArgsAutoScript $inputvar1 $inputvar2]} err] } {
                lappend retval [list Sequence: $i argv is: $inputvar1 argc is: $inputvar2 EXPECTED: [$outVar RETURNED: $err]
            }
            if {$result != $outVar} {
                lappend retval [list Sequence: $i argv is: $inputvar1 argc is: $inputvar2 EXPECTED: $outVar RETURNED: $result]
            }
        }
        if {$retval == ""} {
            return 0
        }
        return $retval
    }
    -result { 0 }
    -cleanup {dropAll AutoScript}
}
# RE-421
test tcl_unit_getToolsList {Unit test for getToolsList proc} {
    -setup {}
    -body {
        set retval ""
        set result ""

        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            set inputvar1 [set product$i]
            set inputvar2 [set e_file$i]
            set outVar [set outval$i]
            if { [catch {set result [getToolsList $inputvar1 $inputvar2]} err] } {
                lappend retval [list Sequence: $i argv is: $inputvar1 argc is: $inputvar2 EXPECTED: $outVar RETURNED: $err]
            }
            if {$result != $outVar} {
                lappend retval [list Sequence: $i argv is: $inputvar1 argc is: $inputvar2 EXPECTED: $outVar RETURNED: $result]
            }
        }
        if {$retval == ""} {
            return 0
        }
        return $retval
    }
    -result { 0 }
    -cleanup {dropAll AutoScript}
}
# RE-421
test tcl_unit_pauseOnIndexScript {Unit test for pauseOnIndexScript proc} {
    -setup {}
    -body {
        set retval ""
        set result ""

        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            set inputvar1 [set scriptname$i]
            set outVar [set outval$i]
            if { [catch {set result [pauseOnIndexScript $inputvar1]} err] } {
                lappend retval [list Sequence: $i Script Name is: $inputvar1 EXPECTED: $outVar RETURNED: $err]
            }
            if {$result != $outVar} {
                lappend retval [list Sequence: $i Script Name is: $inputvar1 EXPECTED: $outVar RETURNED: $result]
            }
        }
        if {$retval == ""} {
            return 0
        }
        return $retval
    }
    -result { 0 }
    -cleanup {dropAll AutoScript}
}
# RE-422
test tcl_unit_checkResources {Unit test for checkResources proc} {
    -setup {}
    -body {
        set retval ""
        set result ""
        if {$scenario == "positive"} {
            set fid [open FDD03020000.sql w]
            close $fid
        }
        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            set inputvar1 [set tcl_tools$i]
            set inputvar2 [set driverfile$i]
            set outVar [set outval$i]
            if { [catch {set result [checkResources $inputvar1 $inputvar2]} err] } {
                lappend retval [list Sequence: $i TCL Tools are: $inputvar1 Driver file is: $inputvar2 EXPECTED: $outVar RETURNED: $err]
            }
            if {$result != $outVar} {
                lappend retval [list Sequence: $i TCL Tools are: $inputvar1 Driver file is: $inputvar2 EXPECTED: $outVar RETURNED: $result]
            }
        }
        if { [file exists FDD03020000.sql]} {
            # delete testing file from current directory
            file delete -force FDD03020000.sql
        }
        if {$retval == ""} {
            return 0
        }
        return $retval
    }
    -result { 0 }
    -cleanup {dropAll AutoScript}
}
# RE-422
test tcl_unit_usage_Autoscript  {Unit test for usage_Autoscript proc} {
    -setup {}
    -body {

        set retval ""

        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            if { [catch {usage_Autoscript} err] } {
                set retval "Cannot execute usage_Autoscript $err"
                return $retval
            }
            if {$retval == ""} {
                return 0
            }
            return 1
        }

    }
    -result { 0 }
    -cleanup {dropAll autoScript}
}

# RE-348
test tcl_unit_checkIndexes {Unit test for printHeader proc} {
    -setup {}
    -body {
return 0
        set retval ""
        set result ""
       if { [catch {getLogonHandle $targetConnection} dbh] } {
               set retVal "Could not connect to $targetConnection"
        }

        for {set i 1} {$i <= $no_of_scenarios} {incr i} {

            set fh [open $log w]

            catch {set result [checkIndexes $currentMod $targetMod $dbh $fh ""]} err

            foreach line $result {

                if {$line != $outval} {
                    return 0
                } else {
                    lappend retval [list Sequence: $i EXPECTED: "$outval" RETURNED: "$line"]
                }
            }

            close $fh

            catch {file delete -force $log}

        }

        if {$retval!=""} {
            return $retval
        }
    }
    -result { 0 }
    -cleanup {dropAll preUpgradeEval}
}
# RE-348
test tcl_unit_analyzeTblsp {Unit test for analyzeTblsp proc} {
    -setup {}
    -body {

        set retval ""
        set result ""
        set final ""

        for {set i 1} {$i <= $no_of_scenarios} {incr i} {


            if { [catch {getLogonHandle $targetConnection} dbh] } {
                set retVal "Could not connect to $targetConnection"
            }

            set fhtbs [open $Tblsplog w]

            catch {set result [analyzeTblsp "$fhtbs" "$dbh" ""]} err

            set files [glob CareRadius_$targetConnection_schemaVersion\_Analysis*.txt]

            if { $files == "" } {
              lappend retval [list Sequence: $i EXPECTED: "CareRadius_$targetConnection_schemaVersion\_Analysis*.txt file" RETURNED: "$files"]
            } else {
                # todo: this is probably not working in CR3+  probably remove this
            # foreach CRfile $files {
                # set CRfh [open $CRfile r]
                # set logdata [split [read $CRfh] \n]

                # foreach line $logdata {
                    # if {$line != ""} {
                        # set tblspace [lindex $line 0]
                        # regsub -all {\s} $tblspace {} final

                        # if {[lindex $final 0] == [lindex $act_tblsp_lst 0] || [lindex $final 0]  == [lindex $act_tblsp_lst 1]} {
                            # return 0
                        # } else {
                            # lappend retval [list Sequence: $i EXPECTED: "[lindex $act_tblsp_lst 0]" RETURNED: "[lindex $final 0]"]
                        # }
                    # }
                # }
                # close $CRfh
            # }
            }

            catch {file delete -force $files}
            catch {file delete -force $Tblsplog}

        }

        if {$retval!=""} {
            return $retval
        } else { return 0 }

    }
    -result { 0 }
    -cleanup {dropAll preUpgradeEval}
}
# RE-423
test tcl_unit_runDropColumns {Unit test for runDropColumns proc} {
    -setup {}
    -body {
        set retval ""
        set result ""

        if { [catch {getLogonHandle $targetConnection} dbh] } {
               set retVal "Could not connect to $targetConnection"
        }
        if {$scenario =="positive"} {
            set SQL_Statement "CREATE TABLE TEST (column1 varchar2(10),column2 varchar2(10), column3 varchar2(10))"
            if {[catch {execsql use $dbh $SQL_Statement} err ] || $err < 0} {
                return $err
            }
            set SQL_Statement "ALTER TABLE TEST SET unused (column1)"
            if {[catch {execsql use $dbh $SQL_Statement} err ] || $err < 0} {
                return $err
            }
        }
        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            set inputvar1 [set scripts$i]
            set inputvar2 [set scriptDir$i]
            set outVar outval$i
            set scriptDirectory [pwd]$inputvar2
            if { [catch {set result [runDropColumns $dbh $inputvar1 $scriptDirectory]} err] } {
                set result $err
            }
            if {$scenario == "positive"} {
                set SQL_Statement "select table_name from all_unused_col_tabs into :result where table_name='TEST'"
                if {[catch {execsql use $dbh $SQL_Statement} err ] || $err < 0} {
                    return $err
                }
            }
            if {$result != $outVar} {
                lappend retval [list Sequence: $i Script is: $inputvar1 Script dir is: $scriptDirectory EXPECTED: $outVar RETURNED: $result]
            }
        }
        set SQL_Statement "drop table TEST cascade constraints"
        catch {execsql use $dbh $SQL_Statement} err
        if {$retval == ""} {
            return 0
        }
        return $retval
    }
    -result { 0 }
    -cleanup {dropAll AutoScript}
}
# RE-423
test tcl_unit_codeFailureMessage {Unit test for codeFailureMessage proc} {
    -setup {}
    -body {
        set retval ""
        set result ""

        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            set inputvar1 [set conflict_codes$i]
            set inputvar2 [set silent$i]
            set outVar [set outval$i]

            if { [catch {set result [codeFailureMessage $inputvar1 $inputvar2]} err] } {
                lappend retval [list Sequence: $i Conflict code is: $inputvar1 Silent is: $inputvar2 EXPECTED: $outVar RETURNED: $err]
            }
            if {$result != $outVar} {
                lappend retval [list Sequence: $i Conflict code is: $inputvar1 Silent is: $inputvar2 EXPECTED: $outVar RETURNED: $result]
            }
        }
        if {$retval == ""} {
            return 0
        }
        return $retval
    }
    -result { 0 }
    -cleanup {dropAll AutoScript}
}

# RE-425
test tcl_unit_conversionFailure {Unit test for conversionFailure  proc} {
    -setup {}
    -body {

        set retval ""

        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            if { [catch {conversionFailure $displayDB $startVersion $targetVersion $outDir} err] } {
                set retval "Cannot execute AutoScript.version $err"
                return $retval
            }
            if {$retval == ""} {
                return 0
            }
            return 1
        }

    }
    -result { 0 }
    -cleanup {dropAll autoScript}
}
# RE-425
test tcl_unit_preConversionFailure {Unit test for preConversionFailure  proc} {
    -setup {}
    -body {

        set retval ""

        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            if { [catch {preConversionFailure $displayDB $startVersion $targetVersion $outDir} err] } {
                set retval "Cannot execute AutoScript.version $err"
                return $retval
            }
            if {$retval == ""} {
                return 0
            }
            return 1
        }

    }
    -result { 0 }
    -cleanup {dropAll autoScript}
}
# RE-425
test tcl_unit_AutoScript.getDescription  {Unit test for AutoScript.getDescription   proc} {
    -setup {}
    -body {

        set retval ""

        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            if { [catch {AutoScript.getDescription} err] } {
                set retval "Cannot execute AutoScript.version $err"
                return $retval
            }
            if {$retval == ""} {
                return 0
            }
            return 1
        }

    }
    -result { 0 }
    -cleanup {dropAll autoScript}
}
test tcl_unit_AutoScript.getPLSQLFileVersion  {Unit test for AutoScript.common_utilities.getPLSQLFileVersion   proc} {
    -setup {}
    -body {
        set err ""
        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            set val [lindex [getPLSQLFileVersion [file join [getInfo WORKING_DIRECTORY] "Packages" LANDA_CONVERSION_BODY.sql]] 0]
            if {$retval != $val} {
                lappend err "expected $retval returned $val"
            }
        }
        return $err
    }
    -result {}
    -cleanup {dropAll autoScript}
}
test tcl_unit_p_compareConstraints {Unit test for p_compareConstraints proc} {
    -setup {}
    -body {
        set results ""
        for {set i 1} {$i <= $no_of_scenarios} {incr i} {
            setNullResults
            setInitialArrays
            getConnectionSetup modelDef $model [getInfo MODEL_FILES_DIRECTORY]
            getConnectionSetup targetDef $model [getInfo MODEL_FILES_DIRECTORY]
            set modelColData [set model_colData$i]
            set modelConsKey [set model_cons_key$i]
            set modelHeader [set model_header$i]
            set modelKey [set model_key$i]
            set targetColData [set target_colData$i]
            set modelConsCol [set model_cons_col$i]
            set targetConsCol [set target_cons_col$i]
            set expectedResult [set expected_Result$i]
            set modelDef(USER_CONS_COLUMNS.header) [set targetDef(USER_CONS_COLUMNS.header) $modelHeader]
            set modelDef(USER_CONS_COLUMNS.key) [set targetDef(USER_CONS_COLUMNS.key) $modelKey]
            set modelDef(USER_CONS_COLUMNS.data) $modelColData
            set targetDef(USER_CONS_COLUMNS.data) $targetColData
            set modelDef(USER_CONSTRAINTS.key) [set targetDef(USER_CONSTRAINTS.key) $modelConsKey]
            set modelDef(USER_CONSTRAINTS.data) $modelConsCol
            set targetDef(USER_CONSTRAINTS.data) $targetConsCol
            set modelDef(DEF.USER_CONSTRAINTS.data.index.CONSTRAINT_TYPE) [set targetDef(DEF.USER_CONSTRAINTS.data.index.CONSTRAINT_TYPE) 0]
            set modelDef(DEF.USER_CONSTRAINTS.data.index.DELETE_RULE) [set targetDef(DEF.USER_CONSTRAINTS.data.index.DELETE_RULE) 1]
            set modelDef(DEF.USER_CONSTRAINTS.data.index.R_CONSTRAINT_NAME) [set targetDef(DEF.USER_CONSTRAINTS.data.index.R_CONSTRAINT_NAME) 3]
            set modelDef(DEF.USER_CONS_COLUMNS.data.index.COLUMN_NAME) [set targetDef(DEF.USER_CONS_COLUMNS.data.index.COLUMN_NAME) 0]
            set modelDef(DEF.USER_CONSTRAINTS.data.index.INDEX_NAME) [set targetDef(DEF.USER_CONSTRAINTS.data.index.INDEX_NAME) 2]
            set modelDef(DEF.USER_CONSTRAINTS.data.index.VALIDATED) [set targetDef(DEF.USER_CONSTRAINTS.data.index.VALIDATED) 4]
            set modelDef(DEF.USER_CONSTRAINTS.data.index.STATUS) [set targetDef(DEF.USER_CONSTRAINTS.data.index.STATUS) 5]
            set modelDef(DEF.USER_CONSTRAINTS.data) [set targetDef(DEF.USER_CONSTRAINTS.data) "CONSTRAINT_TYPE DELETE_RULE INDEX_NAME R_CONSTRAINT_NAME VALIDATED STATUS"]
            
            # Calling proc p_compareConstraints and it will return the differences
            p_compareConstraints modelDef targetDef
            if {$WARNINGS(RECREATE.CONSTRAINTS) != $expectedResult} {
                lappend results [list Sequence: $i  EXPECTED: $expectedResult RETURNED: $WARNINGS(RECREATE.CONSTRAINTS)]
            }
            unset modelDef targetDef RESULTS WARNINGS
        }
            return $results
    }
    -result { }
    -cleanup {dropAll dbCompare}
}